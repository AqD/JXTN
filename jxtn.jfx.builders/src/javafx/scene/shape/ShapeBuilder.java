// @formatter:off
/*
 * Unlicensed, generated by javafx.ftl
 */

package javafx.scene.shape;

/**
 * {@link Shape}建構器
 *
 * @author JarReflectionDataLoader-1.0.0
 * @version jfxrt.jar
 * @param <Z> 要建構的物件型態(需繼承{@link Shape})
 * @param <B> 建構器本身的型態(需繼承{@link ShapeBuilder})
 */
@javax.annotation.Generated("Generated by javafx.ftl")
@SuppressWarnings("all")
public class ShapeBuilder<Z extends Shape, B extends ShapeBuilder<Z, B>>
        extends javafx.scene.NodeBuilder<Z, B>
{

    private boolean hasFill;
    private javafx.scene.paint.Paint valFill;

    private boolean hasSmooth;
    private boolean valSmooth;

    private boolean hasStroke;
    private javafx.scene.paint.Paint valStroke;

    private boolean hasStrokeDashArray;
    private java.util.Collection<java.lang.Double> valStrokeDashArray;

    private boolean hasStrokeDashOffset;
    private double valStrokeDashOffset;

    private boolean hasStrokeLineCap;
    private javafx.scene.shape.StrokeLineCap valStrokeLineCap;

    private boolean hasStrokeLineJoin;
    private javafx.scene.shape.StrokeLineJoin valStrokeLineJoin;

    private boolean hasStrokeMiterLimit;
    private double valStrokeMiterLimit;

    private boolean hasStrokeType;
    private javafx.scene.shape.StrokeType valStrokeType;

    private boolean hasStrokeWidth;
    private double valStrokeWidth;

    private boolean bound1Fill;
    private boolean bound2Fill;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.paint.Paint> obsrv1Fill;
    private javafx.beans.property.Property<javafx.scene.paint.Paint> obsrv2Fill;

    private boolean bound1Smooth;
    private boolean bound2Smooth;
    private javafx.beans.value.ObservableValue<? extends Boolean> obsrv1Smooth;
    private javafx.beans.property.Property<Boolean> obsrv2Smooth;

    private boolean bound1StrokeDashOffset;
    private boolean bound2StrokeDashOffset;
    private javafx.beans.value.ObservableValue<? extends Number> obsrv1StrokeDashOffset;
    private javafx.beans.property.Property<Number> obsrv2StrokeDashOffset;

    private boolean bound1StrokeLineCap;
    private boolean bound2StrokeLineCap;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.shape.StrokeLineCap> obsrv1StrokeLineCap;
    private javafx.beans.property.Property<javafx.scene.shape.StrokeLineCap> obsrv2StrokeLineCap;

    private boolean bound1StrokeLineJoin;
    private boolean bound2StrokeLineJoin;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.shape.StrokeLineJoin> obsrv1StrokeLineJoin;
    private javafx.beans.property.Property<javafx.scene.shape.StrokeLineJoin> obsrv2StrokeLineJoin;

    private boolean bound1StrokeMiterLimit;
    private boolean bound2StrokeMiterLimit;
    private javafx.beans.value.ObservableValue<? extends Number> obsrv1StrokeMiterLimit;
    private javafx.beans.property.Property<Number> obsrv2StrokeMiterLimit;

    private boolean bound1Stroke;
    private boolean bound2Stroke;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.paint.Paint> obsrv1Stroke;
    private javafx.beans.property.Property<javafx.scene.paint.Paint> obsrv2Stroke;

    private boolean bound1StrokeType;
    private boolean bound2StrokeType;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.shape.StrokeType> obsrv1StrokeType;
    private javafx.beans.property.Property<javafx.scene.shape.StrokeType> obsrv2StrokeType;

    private boolean bound1StrokeWidth;
    private boolean bound2StrokeWidth;
    private javafx.beans.value.ObservableValue<? extends Number> obsrv1StrokeWidth;
    private javafx.beans.property.Property<Number> obsrv2StrokeWidth;

    @Override
    public void applyTo(Z instance)
    {
        super.applyTo(instance);
        if (this.hasFill)
            instance.setFill(this.valFill);
        if (this.hasSmooth)
            instance.setSmooth(this.valSmooth);
        if (this.hasStroke)
            instance.setStroke(this.valStroke);
        if (this.hasStrokeDashArray)
            instance.getStrokeDashArray().setAll(this.valStrokeDashArray);
        if (this.hasStrokeDashOffset)
            instance.setStrokeDashOffset(this.valStrokeDashOffset);
        if (this.hasStrokeLineCap)
            instance.setStrokeLineCap(this.valStrokeLineCap);
        if (this.hasStrokeLineJoin)
            instance.setStrokeLineJoin(this.valStrokeLineJoin);
        if (this.hasStrokeMiterLimit)
            instance.setStrokeMiterLimit(this.valStrokeMiterLimit);
        if (this.hasStrokeType)
            instance.setStrokeType(this.valStrokeType);
        if (this.hasStrokeWidth)
            instance.setStrokeWidth(this.valStrokeWidth);
        if (this.bound1Fill)
            instance.fillProperty().bind(this.obsrv1Fill);
        if (this.bound2Fill)
            instance.fillProperty().bindBidirectional(this.obsrv2Fill);
        if (this.bound1Smooth)
            instance.smoothProperty().bind(this.obsrv1Smooth);
        if (this.bound2Smooth)
            instance.smoothProperty().bindBidirectional(this.obsrv2Smooth);
        if (this.bound1StrokeDashOffset)
            instance.strokeDashOffsetProperty().bind(this.obsrv1StrokeDashOffset);
        if (this.bound2StrokeDashOffset)
            instance.strokeDashOffsetProperty().bindBidirectional(this.obsrv2StrokeDashOffset);
        if (this.bound1StrokeLineCap)
            instance.strokeLineCapProperty().bind(this.obsrv1StrokeLineCap);
        if (this.bound2StrokeLineCap)
            instance.strokeLineCapProperty().bindBidirectional(this.obsrv2StrokeLineCap);
        if (this.bound1StrokeLineJoin)
            instance.strokeLineJoinProperty().bind(this.obsrv1StrokeLineJoin);
        if (this.bound2StrokeLineJoin)
            instance.strokeLineJoinProperty().bindBidirectional(this.obsrv2StrokeLineJoin);
        if (this.bound1StrokeMiterLimit)
            instance.strokeMiterLimitProperty().bind(this.obsrv1StrokeMiterLimit);
        if (this.bound2StrokeMiterLimit)
            instance.strokeMiterLimitProperty().bindBidirectional(this.obsrv2StrokeMiterLimit);
        if (this.bound1Stroke)
            instance.strokeProperty().bind(this.obsrv1Stroke);
        if (this.bound2Stroke)
            instance.strokeProperty().bindBidirectional(this.obsrv2Stroke);
        if (this.bound1StrokeType)
            instance.strokeTypeProperty().bind(this.obsrv1StrokeType);
        if (this.bound2StrokeType)
            instance.strokeTypeProperty().bindBidirectional(this.obsrv2StrokeType);
        if (this.bound1StrokeWidth)
            instance.strokeWidthProperty().bind(this.obsrv1StrokeWidth);
        if (this.bound2StrokeWidth)
            instance.strokeWidthProperty().bindBidirectional(this.obsrv2StrokeWidth);
    }

    /**
     * 設定屬性{@link Shape#setFill(javafx.scene.paint.Paint)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B fill(javafx.scene.paint.Paint value)
    {
        this.hasFill = true;
        this.valFill = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#setSmooth(boolean)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B smooth(boolean value)
    {
        this.hasSmooth = true;
        this.valSmooth = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#setStroke(javafx.scene.paint.Paint)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B stroke(javafx.scene.paint.Paint value)
    {
        this.hasStroke = true;
        this.valStroke = value;
        return (B) this;
    }

    /**
     * 設定集合屬性{@link Shape#getStrokeDashArray}的內容
     *
     * @param value 新的集合內容
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B strokeDashArray(java.util.Collection<java.lang.Double> value)
    {
        this.hasStrokeDashArray = true;
        this.valStrokeDashArray = value;
        return (B) this;
    }

    /**
     * 設定集合屬性{@link Shape#getStrokeDashArray}的內容
     *
     * @param value 新的集合內容
     * @return 目前的建構器(this)
     */
    @SafeVarargs
    @SuppressWarnings("unchecked")
    public final B strokeDashArray(java.lang.Double... value)
    {
        this.hasStrokeDashArray = true;
        this.valStrokeDashArray = java.util.Arrays.asList(value);
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#setStrokeDashOffset(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B strokeDashOffset(double value)
    {
        this.hasStrokeDashOffset = true;
        this.valStrokeDashOffset = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#setStrokeLineCap(javafx.scene.shape.StrokeLineCap)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B strokeLineCap(javafx.scene.shape.StrokeLineCap value)
    {
        this.hasStrokeLineCap = true;
        this.valStrokeLineCap = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#setStrokeLineJoin(javafx.scene.shape.StrokeLineJoin)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B strokeLineJoin(javafx.scene.shape.StrokeLineJoin value)
    {
        this.hasStrokeLineJoin = true;
        this.valStrokeLineJoin = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#setStrokeMiterLimit(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B strokeMiterLimit(double value)
    {
        this.hasStrokeMiterLimit = true;
        this.valStrokeMiterLimit = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#setStrokeType(javafx.scene.shape.StrokeType)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B strokeType(javafx.scene.shape.StrokeType value)
    {
        this.hasStrokeType = true;
        this.valStrokeType = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#setStrokeWidth(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B strokeWidth(double value)
    {
        this.hasStrokeWidth = true;
        this.valStrokeWidth = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#fillProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindFill(javafx.beans.value.ObservableValue<? extends javafx.scene.paint.Paint> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Fill = true;
        this.obsrv1Fill = source;
        this.bound2Fill = false;
        this.obsrv2Fill = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#fillProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalFill(javafx.beans.property.Property<javafx.scene.paint.Paint> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Fill = false;
        this.obsrv1Fill = null;
        this.bound2Fill = true;
        this.obsrv2Fill = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#smoothProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindSmooth(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Smooth = true;
        this.obsrv1Smooth = source;
        this.bound2Smooth = false;
        this.obsrv2Smooth = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#smoothProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalSmooth(javafx.beans.property.Property<Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Smooth = false;
        this.obsrv1Smooth = null;
        this.bound2Smooth = true;
        this.obsrv2Smooth = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#strokeDashOffsetProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindStrokeDashOffset(javafx.beans.value.ObservableValue<? extends Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1StrokeDashOffset = true;
        this.obsrv1StrokeDashOffset = source;
        this.bound2StrokeDashOffset = false;
        this.obsrv2StrokeDashOffset = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#strokeDashOffsetProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalStrokeDashOffset(javafx.beans.property.Property<Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1StrokeDashOffset = false;
        this.obsrv1StrokeDashOffset = null;
        this.bound2StrokeDashOffset = true;
        this.obsrv2StrokeDashOffset = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#strokeLineCapProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindStrokeLineCap(javafx.beans.value.ObservableValue<? extends javafx.scene.shape.StrokeLineCap> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1StrokeLineCap = true;
        this.obsrv1StrokeLineCap = source;
        this.bound2StrokeLineCap = false;
        this.obsrv2StrokeLineCap = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#strokeLineCapProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalStrokeLineCap(javafx.beans.property.Property<javafx.scene.shape.StrokeLineCap> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1StrokeLineCap = false;
        this.obsrv1StrokeLineCap = null;
        this.bound2StrokeLineCap = true;
        this.obsrv2StrokeLineCap = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#strokeLineJoinProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindStrokeLineJoin(javafx.beans.value.ObservableValue<? extends javafx.scene.shape.StrokeLineJoin> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1StrokeLineJoin = true;
        this.obsrv1StrokeLineJoin = source;
        this.bound2StrokeLineJoin = false;
        this.obsrv2StrokeLineJoin = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#strokeLineJoinProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalStrokeLineJoin(javafx.beans.property.Property<javafx.scene.shape.StrokeLineJoin> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1StrokeLineJoin = false;
        this.obsrv1StrokeLineJoin = null;
        this.bound2StrokeLineJoin = true;
        this.obsrv2StrokeLineJoin = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#strokeMiterLimitProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindStrokeMiterLimit(javafx.beans.value.ObservableValue<? extends Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1StrokeMiterLimit = true;
        this.obsrv1StrokeMiterLimit = source;
        this.bound2StrokeMiterLimit = false;
        this.obsrv2StrokeMiterLimit = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#strokeMiterLimitProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalStrokeMiterLimit(javafx.beans.property.Property<Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1StrokeMiterLimit = false;
        this.obsrv1StrokeMiterLimit = null;
        this.bound2StrokeMiterLimit = true;
        this.obsrv2StrokeMiterLimit = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#strokeProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindStroke(javafx.beans.value.ObservableValue<? extends javafx.scene.paint.Paint> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Stroke = true;
        this.obsrv1Stroke = source;
        this.bound2Stroke = false;
        this.obsrv2Stroke = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#strokeProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalStroke(javafx.beans.property.Property<javafx.scene.paint.Paint> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Stroke = false;
        this.obsrv1Stroke = null;
        this.bound2Stroke = true;
        this.obsrv2Stroke = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#strokeTypeProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindStrokeType(javafx.beans.value.ObservableValue<? extends javafx.scene.shape.StrokeType> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1StrokeType = true;
        this.obsrv1StrokeType = source;
        this.bound2StrokeType = false;
        this.obsrv2StrokeType = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#strokeTypeProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalStrokeType(javafx.beans.property.Property<javafx.scene.shape.StrokeType> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1StrokeType = false;
        this.obsrv1StrokeType = null;
        this.bound2StrokeType = true;
        this.obsrv2StrokeType = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#strokeWidthProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindStrokeWidth(javafx.beans.value.ObservableValue<? extends Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1StrokeWidth = true;
        this.obsrv1StrokeWidth = source;
        this.bound2StrokeWidth = false;
        this.obsrv2StrokeWidth = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Shape#strokeWidthProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalStrokeWidth(javafx.beans.property.Property<Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1StrokeWidth = false;
        this.obsrv1StrokeWidth = null;
        this.bound2StrokeWidth = true;
        this.obsrv2StrokeWidth = source;
        return (B) this;
    }
}
