// @formatter:off
/*
 * Unlicensed, generated by javafx.ftl
 */

package javafx.scene.text;

/**
 * {@link Text}建構器
 *
 * @author JarReflectionDataLoader-1.0.0
 * @version jfxrt.jar
 * @param <Z> 要建構的物件型態(需繼承{@link Text})
 * @param <B> 建構器本身的型態(需繼承{@link TextBuilder})
 */
@javax.annotation.Generated("Generated by javafx.ftl")
@SuppressWarnings("all")
public class TextBuilder<Z extends Text, B extends TextBuilder<Z, B>>
        extends javafx.scene.shape.ShapeBuilder<Z, B>
{

    private boolean hasBoundsType;
    private javafx.scene.text.TextBoundsType valBoundsType;

    private boolean hasFont;
    private javafx.scene.text.Font valFont;

    private boolean hasFontSmoothingType;
    private javafx.scene.text.FontSmoothingType valFontSmoothingType;

    private boolean hasLineSpacing;
    private double valLineSpacing;

    private boolean hasStrikethrough;
    private boolean valStrikethrough;

    private boolean hasText;
    private java.lang.String valText;

    private boolean hasTextAlignment;
    private javafx.scene.text.TextAlignment valTextAlignment;

    private boolean hasTextOrigin;
    private javafx.geometry.VPos valTextOrigin;

    private boolean hasUnderline;
    private boolean valUnderline;

    private boolean hasWrappingWidth;
    private double valWrappingWidth;

    private boolean hasX;
    private double valX;

    private boolean hasY;
    private double valY;

    private boolean boundBoundsType;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.text.TextBoundsType> obsrvBoundsType;

    private boolean boundFont;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.text.Font> obsrvFont;

    private boolean boundFontSmoothingType;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.text.FontSmoothingType> obsrvFontSmoothingType;

    private boolean boundLineSpacing;
    private javafx.beans.value.ObservableValue<? extends Double> obsrvLineSpacing;

    private boolean boundStrikethrough;
    private javafx.beans.value.ObservableValue<? extends Boolean> obsrvStrikethrough;

    private boolean boundTextAlignment;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.text.TextAlignment> obsrvTextAlignment;

    private boolean boundTextOrigin;
    private javafx.beans.value.ObservableValue<? extends javafx.geometry.VPos> obsrvTextOrigin;

    private boolean boundText;
    private javafx.beans.value.ObservableValue<? extends String> obsrvText;

    private boolean boundUnderline;
    private javafx.beans.value.ObservableValue<? extends Boolean> obsrvUnderline;

    private boolean boundWrappingWidth;
    private javafx.beans.value.ObservableValue<? extends Double> obsrvWrappingWidth;

    private boolean boundX;
    private javafx.beans.value.ObservableValue<? extends Double> obsrvX;

    private boolean boundY;
    private javafx.beans.value.ObservableValue<? extends Double> obsrvY;

    @Override
    public void applyTo(Z instance)
    {
        super.applyTo(instance);
        if (this.hasBoundsType)
            instance.setBoundsType(this.valBoundsType);
        if (this.hasFont)
            instance.setFont(this.valFont);
        if (this.hasFontSmoothingType)
            instance.setFontSmoothingType(this.valFontSmoothingType);
        if (this.hasLineSpacing)
            instance.setLineSpacing(this.valLineSpacing);
        if (this.hasStrikethrough)
            instance.setStrikethrough(this.valStrikethrough);
        if (this.hasText)
            instance.setText(this.valText);
        if (this.hasTextAlignment)
            instance.setTextAlignment(this.valTextAlignment);
        if (this.hasTextOrigin)
            instance.setTextOrigin(this.valTextOrigin);
        if (this.hasUnderline)
            instance.setUnderline(this.valUnderline);
        if (this.hasWrappingWidth)
            instance.setWrappingWidth(this.valWrappingWidth);
        if (this.hasX)
            instance.setX(this.valX);
        if (this.hasY)
            instance.setY(this.valY);
        if (this.boundBoundsType)
            instance.boundsTypeProperty().bind(this.obsrvBoundsType);
        if (this.boundFont)
            instance.fontProperty().bind(this.obsrvFont);
        if (this.boundFontSmoothingType)
            instance.fontSmoothingTypeProperty().bind(this.obsrvFontSmoothingType);
        if (this.boundLineSpacing)
            instance.lineSpacingProperty().bind(this.obsrvLineSpacing);
        if (this.boundStrikethrough)
            instance.strikethroughProperty().bind(this.obsrvStrikethrough);
        if (this.boundTextAlignment)
            instance.textAlignmentProperty().bind(this.obsrvTextAlignment);
        if (this.boundTextOrigin)
            instance.textOriginProperty().bind(this.obsrvTextOrigin);
        if (this.boundText)
            instance.textProperty().bind(this.obsrvText);
        if (this.boundUnderline)
            instance.underlineProperty().bind(this.obsrvUnderline);
        if (this.boundWrappingWidth)
            instance.wrappingWidthProperty().bind(this.obsrvWrappingWidth);
        if (this.boundX)
            instance.xProperty().bind(this.obsrvX);
        if (this.boundY)
            instance.yProperty().bind(this.obsrvY);
    }

    /**
     * 設定屬性{@link Text#setBoundsType(javafx.scene.text.TextBoundsType)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B boundsType(javafx.scene.text.TextBoundsType value)
    {
        this.hasBoundsType = true;
        this.valBoundsType = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#setFont(javafx.scene.text.Font)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B font(javafx.scene.text.Font value)
    {
        this.hasFont = true;
        this.valFont = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#setFontSmoothingType(javafx.scene.text.FontSmoothingType)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B fontSmoothingType(javafx.scene.text.FontSmoothingType value)
    {
        this.hasFontSmoothingType = true;
        this.valFontSmoothingType = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#setLineSpacing(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B lineSpacing(double value)
    {
        this.hasLineSpacing = true;
        this.valLineSpacing = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#setStrikethrough(boolean)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B strikethrough(boolean value)
    {
        this.hasStrikethrough = true;
        this.valStrikethrough = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#setText(java.lang.String)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B text(java.lang.String value)
    {
        this.hasText = true;
        this.valText = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#setTextAlignment(javafx.scene.text.TextAlignment)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B textAlignment(javafx.scene.text.TextAlignment value)
    {
        this.hasTextAlignment = true;
        this.valTextAlignment = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#setTextOrigin(javafx.geometry.VPos)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B textOrigin(javafx.geometry.VPos value)
    {
        this.hasTextOrigin = true;
        this.valTextOrigin = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#setUnderline(boolean)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B underline(boolean value)
    {
        this.hasUnderline = true;
        this.valUnderline = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#setWrappingWidth(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B wrappingWidth(double value)
    {
        this.hasWrappingWidth = true;
        this.valWrappingWidth = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#setX(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B x(double value)
    {
        this.hasX = true;
        this.valX = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#setY(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B y(double value)
    {
        this.hasY = true;
        this.valY = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#boundsTypeProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBoundsType(javafx.beans.value.ObservableValue<? extends javafx.scene.text.TextBoundsType> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundBoundsType = true;
        this.obsrvBoundsType = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#fontProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindFont(javafx.beans.value.ObservableValue<? extends javafx.scene.text.Font> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundFont = true;
        this.obsrvFont = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#fontSmoothingTypeProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindFontSmoothingType(javafx.beans.value.ObservableValue<? extends javafx.scene.text.FontSmoothingType> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundFontSmoothingType = true;
        this.obsrvFontSmoothingType = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#lineSpacingProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindLineSpacing(javafx.beans.value.ObservableValue<? extends Double> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundLineSpacing = true;
        this.obsrvLineSpacing = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#strikethroughProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindStrikethrough(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundStrikethrough = true;
        this.obsrvStrikethrough = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#textAlignmentProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindTextAlignment(javafx.beans.value.ObservableValue<? extends javafx.scene.text.TextAlignment> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundTextAlignment = true;
        this.obsrvTextAlignment = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#textOriginProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindTextOrigin(javafx.beans.value.ObservableValue<? extends javafx.geometry.VPos> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundTextOrigin = true;
        this.obsrvTextOrigin = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#textProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindText(javafx.beans.value.ObservableValue<? extends String> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundText = true;
        this.obsrvText = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#underlineProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindUnderline(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundUnderline = true;
        this.obsrvUnderline = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#wrappingWidthProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindWrappingWidth(javafx.beans.value.ObservableValue<? extends Double> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundWrappingWidth = true;
        this.obsrvWrappingWidth = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#xProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindX(javafx.beans.value.ObservableValue<? extends Double> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundX = true;
        this.obsrvX = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Text#yProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindY(javafx.beans.value.ObservableValue<? extends Double> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundY = true;
        this.obsrvY = source;
        return (B) this;
    }

    /**
     * 建構{@link Text}物件
     *
     * @return 新的{@link Text}物件實體
     */
    @Override
    @SuppressWarnings("unchecked")
    public Text build()
    {
        Text instance = new Text();
        this.applyTo((Z) instance);
        this.doAfterBuild((Z) instance);
        return instance;
    }
}
