// @formatter:off
/*
 * Unlicensed, generated by javafx.ftl
 */

package javafx.scene;

/**
 * {@link Node}建構器
 *
 * @author JarReflectionDataLoader-1.0.0
 * @version jfxrt.jar
 * @param <Z> 要建構的物件型態(需繼承{@link Node})
 * @param <B> 建構器本身的型態(需繼承{@link NodeBuilder})
 */
@javax.annotation.Generated("Generated by javafx.ftl")
@SuppressWarnings("all")
public class NodeBuilder<Z extends Node, B extends NodeBuilder<Z, B>>
        extends jxtn.jfx.builders.AbstractBuilder<Z, B>
{

    private boolean hasBlendMode;
    private javafx.scene.effect.BlendMode valBlendMode;

    private boolean hasCache;
    private boolean valCache;

    private boolean hasCacheHint;
    private javafx.scene.CacheHint valCacheHint;

    private boolean hasClip;
    private javafx.scene.Node valClip;

    private boolean hasCursor;
    private javafx.scene.Cursor valCursor;

    private boolean hasDepthTest;
    private javafx.scene.DepthTest valDepthTest;

    private boolean hasDisable;
    private boolean valDisable;

    private boolean hasEffect;
    private javafx.scene.effect.Effect valEffect;

    private boolean hasEventDispatcher;
    private javafx.event.EventDispatcher valEventDispatcher;

    private boolean hasFocusTraversable;
    private boolean valFocusTraversable;

    private boolean hasId;
    private java.lang.String valId;

    private boolean hasInputMethodRequests;
    private javafx.scene.input.InputMethodRequests valInputMethodRequests;

    private boolean hasLayoutX;
    private double valLayoutX;

    private boolean hasLayoutY;
    private double valLayoutY;

    private boolean hasManaged;
    private boolean valManaged;

    private boolean hasMouseTransparent;
    private boolean valMouseTransparent;

    private boolean hasNodeOrientation;
    private javafx.geometry.NodeOrientation valNodeOrientation;

    private boolean hasOnContextMenuRequested;
    private javafx.event.EventHandler<? super javafx.scene.input.ContextMenuEvent> valOnContextMenuRequested;

    private boolean hasOnDragDetected;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> valOnDragDetected;

    private boolean hasOnDragDone;
    private javafx.event.EventHandler<? super javafx.scene.input.DragEvent> valOnDragDone;

    private boolean hasOnDragDropped;
    private javafx.event.EventHandler<? super javafx.scene.input.DragEvent> valOnDragDropped;

    private boolean hasOnDragEntered;
    private javafx.event.EventHandler<? super javafx.scene.input.DragEvent> valOnDragEntered;

    private boolean hasOnDragExited;
    private javafx.event.EventHandler<? super javafx.scene.input.DragEvent> valOnDragExited;

    private boolean hasOnDragOver;
    private javafx.event.EventHandler<? super javafx.scene.input.DragEvent> valOnDragOver;

    private boolean hasOnInputMethodTextChanged;
    private javafx.event.EventHandler<? super javafx.scene.input.InputMethodEvent> valOnInputMethodTextChanged;

    private boolean hasOnKeyPressed;
    private javafx.event.EventHandler<? super javafx.scene.input.KeyEvent> valOnKeyPressed;

    private boolean hasOnKeyReleased;
    private javafx.event.EventHandler<? super javafx.scene.input.KeyEvent> valOnKeyReleased;

    private boolean hasOnKeyTyped;
    private javafx.event.EventHandler<? super javafx.scene.input.KeyEvent> valOnKeyTyped;

    private boolean hasOnMouseClicked;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> valOnMouseClicked;

    private boolean hasOnMouseDragEntered;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent> valOnMouseDragEntered;

    private boolean hasOnMouseDragExited;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent> valOnMouseDragExited;

    private boolean hasOnMouseDragOver;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent> valOnMouseDragOver;

    private boolean hasOnMouseDragReleased;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent> valOnMouseDragReleased;

    private boolean hasOnMouseDragged;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> valOnMouseDragged;

    private boolean hasOnMouseEntered;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> valOnMouseEntered;

    private boolean hasOnMouseExited;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> valOnMouseExited;

    private boolean hasOnMouseMoved;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> valOnMouseMoved;

    private boolean hasOnMousePressed;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> valOnMousePressed;

    private boolean hasOnMouseReleased;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> valOnMouseReleased;

    private boolean hasOnRotate;
    private javafx.event.EventHandler<? super javafx.scene.input.RotateEvent> valOnRotate;

    private boolean hasOnRotationFinished;
    private javafx.event.EventHandler<? super javafx.scene.input.RotateEvent> valOnRotationFinished;

    private boolean hasOnRotationStarted;
    private javafx.event.EventHandler<? super javafx.scene.input.RotateEvent> valOnRotationStarted;

    private boolean hasOnScroll;
    private javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent> valOnScroll;

    private boolean hasOnScrollFinished;
    private javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent> valOnScrollFinished;

    private boolean hasOnScrollStarted;
    private javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent> valOnScrollStarted;

    private boolean hasOnSwipeDown;
    private javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent> valOnSwipeDown;

    private boolean hasOnSwipeLeft;
    private javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent> valOnSwipeLeft;

    private boolean hasOnSwipeRight;
    private javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent> valOnSwipeRight;

    private boolean hasOnSwipeUp;
    private javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent> valOnSwipeUp;

    private boolean hasOnTouchMoved;
    private javafx.event.EventHandler<? super javafx.scene.input.TouchEvent> valOnTouchMoved;

    private boolean hasOnTouchPressed;
    private javafx.event.EventHandler<? super javafx.scene.input.TouchEvent> valOnTouchPressed;

    private boolean hasOnTouchReleased;
    private javafx.event.EventHandler<? super javafx.scene.input.TouchEvent> valOnTouchReleased;

    private boolean hasOnTouchStationary;
    private javafx.event.EventHandler<? super javafx.scene.input.TouchEvent> valOnTouchStationary;

    private boolean hasOnZoom;
    private javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent> valOnZoom;

    private boolean hasOnZoomFinished;
    private javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent> valOnZoomFinished;

    private boolean hasOnZoomStarted;
    private javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent> valOnZoomStarted;

    private boolean hasOpacity;
    private double valOpacity;

    private boolean hasPickOnBounds;
    private boolean valPickOnBounds;

    private boolean hasRotate;
    private double valRotate;

    private boolean hasRotationAxis;
    private javafx.geometry.Point3D valRotationAxis;

    private boolean hasScaleX;
    private double valScaleX;

    private boolean hasScaleY;
    private double valScaleY;

    private boolean hasScaleZ;
    private double valScaleZ;

    private boolean hasStyle;
    private java.lang.String valStyle;

    private boolean hasStyleClass;
    private java.util.Collection<java.lang.String> valStyleClass;

    private boolean hasTransforms;
    private java.util.Collection<javafx.scene.transform.Transform> valTransforms;

    private boolean hasTranslateX;
    private double valTranslateX;

    private boolean hasTranslateY;
    private double valTranslateY;

    private boolean hasTranslateZ;
    private double valTranslateZ;

    private boolean hasUserData;
    private java.lang.Object valUserData;

    private boolean hasVisible;
    private boolean valVisible;

    private boolean hasAnchorPane_bottomAnchor;
    private java.lang.Double valAnchorPane_bottomAnchor;

    private boolean hasAnchorPane_leftAnchor;
    private java.lang.Double valAnchorPane_leftAnchor;

    private boolean hasAnchorPane_rightAnchor;
    private java.lang.Double valAnchorPane_rightAnchor;

    private boolean hasAnchorPane_topAnchor;
    private java.lang.Double valAnchorPane_topAnchor;

    private boolean hasBorderPane_alignment;
    private javafx.geometry.Pos valBorderPane_alignment;

    private boolean hasBorderPane_margin;
    private javafx.geometry.Insets valBorderPane_margin;

    private boolean hasFlowPane_margin;
    private javafx.geometry.Insets valFlowPane_margin;

    private boolean hasGridPane_columnIndex;
    private java.lang.Integer valGridPane_columnIndex;

    private boolean hasGridPane_columnSpan;
    private java.lang.Integer valGridPane_columnSpan;

    private boolean hasGridPane_fillHeight;
    private java.lang.Boolean valGridPane_fillHeight;

    private boolean hasGridPane_fillWidth;
    private java.lang.Boolean valGridPane_fillWidth;

    private boolean hasGridPane_halignment;
    private javafx.geometry.HPos valGridPane_halignment;

    private boolean hasGridPane_hgrow;
    private javafx.scene.layout.Priority valGridPane_hgrow;

    private boolean hasGridPane_margin;
    private javafx.geometry.Insets valGridPane_margin;

    private boolean hasGridPane_rowIndex;
    private java.lang.Integer valGridPane_rowIndex;

    private boolean hasGridPane_rowSpan;
    private java.lang.Integer valGridPane_rowSpan;

    private boolean hasGridPane_valignment;
    private javafx.geometry.VPos valGridPane_valignment;

    private boolean hasGridPane_vgrow;
    private javafx.scene.layout.Priority valGridPane_vgrow;

    private boolean hasHBox_hgrow;
    private javafx.scene.layout.Priority valHBox_hgrow;

    private boolean hasHBox_margin;
    private javafx.geometry.Insets valHBox_margin;

    private boolean hasSplitPane_resizableWithParent;
    private java.lang.Boolean valSplitPane_resizableWithParent;

    private boolean hasStackPane_alignment;
    private javafx.geometry.Pos valStackPane_alignment;

    private boolean hasStackPane_margin;
    private javafx.geometry.Insets valStackPane_margin;

    private boolean hasTilePane_alignment;
    private javafx.geometry.Pos valTilePane_alignment;

    private boolean hasTilePane_margin;
    private javafx.geometry.Insets valTilePane_margin;

    private boolean hasVBox_margin;
    private javafx.geometry.Insets valVBox_margin;

    private boolean hasVBox_vgrow;
    private javafx.scene.layout.Priority valVBox_vgrow;

    private boolean bound1BlendMode;
    private boolean bound2BlendMode;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.effect.BlendMode> obsrv1BlendMode;
    private javafx.beans.property.Property<javafx.scene.effect.BlendMode> obsrv2BlendMode;

    private boolean bound1CacheHint;
    private boolean bound2CacheHint;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.CacheHint> obsrv1CacheHint;
    private javafx.beans.property.Property<javafx.scene.CacheHint> obsrv2CacheHint;

    private boolean bound1Cache;
    private boolean bound2Cache;
    private javafx.beans.value.ObservableValue<? extends Boolean> obsrv1Cache;
    private javafx.beans.property.Property<Boolean> obsrv2Cache;

    private boolean bound1Clip;
    private boolean bound2Clip;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.Node> obsrv1Clip;
    private javafx.beans.property.Property<javafx.scene.Node> obsrv2Clip;

    private boolean bound1Cursor;
    private boolean bound2Cursor;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.Cursor> obsrv1Cursor;
    private javafx.beans.property.Property<javafx.scene.Cursor> obsrv2Cursor;

    private boolean bound1DepthTest;
    private boolean bound2DepthTest;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.DepthTest> obsrv1DepthTest;
    private javafx.beans.property.Property<javafx.scene.DepthTest> obsrv2DepthTest;

    private boolean bound1Disable;
    private boolean bound2Disable;
    private javafx.beans.value.ObservableValue<? extends Boolean> obsrv1Disable;
    private javafx.beans.property.Property<Boolean> obsrv2Disable;

    private boolean bound1Effect;
    private boolean bound2Effect;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.effect.Effect> obsrv1Effect;
    private javafx.beans.property.Property<javafx.scene.effect.Effect> obsrv2Effect;

    private boolean bound1EventDispatcher;
    private boolean bound2EventDispatcher;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventDispatcher> obsrv1EventDispatcher;
    private javafx.beans.property.Property<javafx.event.EventDispatcher> obsrv2EventDispatcher;

    private boolean bound1FocusTraversable;
    private boolean bound2FocusTraversable;
    private javafx.beans.value.ObservableValue<? extends Boolean> obsrv1FocusTraversable;
    private javafx.beans.property.Property<Boolean> obsrv2FocusTraversable;

    private boolean bound1Id;
    private boolean bound2Id;
    private javafx.beans.value.ObservableValue<? extends String> obsrv1Id;
    private javafx.beans.property.Property<String> obsrv2Id;

    private boolean bound1InputMethodRequests;
    private boolean bound2InputMethodRequests;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.input.InputMethodRequests> obsrv1InputMethodRequests;
    private javafx.beans.property.Property<javafx.scene.input.InputMethodRequests> obsrv2InputMethodRequests;

    private boolean bound1LayoutX;
    private boolean bound2LayoutX;
    private javafx.beans.value.ObservableValue<? extends Number> obsrv1LayoutX;
    private javafx.beans.property.Property<Number> obsrv2LayoutX;

    private boolean bound1LayoutY;
    private boolean bound2LayoutY;
    private javafx.beans.value.ObservableValue<? extends Number> obsrv1LayoutY;
    private javafx.beans.property.Property<Number> obsrv2LayoutY;

    private boolean bound1Managed;
    private boolean bound2Managed;
    private javafx.beans.value.ObservableValue<? extends Boolean> obsrv1Managed;
    private javafx.beans.property.Property<Boolean> obsrv2Managed;

    private boolean bound1MouseTransparent;
    private boolean bound2MouseTransparent;
    private javafx.beans.value.ObservableValue<? extends Boolean> obsrv1MouseTransparent;
    private javafx.beans.property.Property<Boolean> obsrv2MouseTransparent;

    private boolean bound1NodeOrientation;
    private boolean bound2NodeOrientation;
    private javafx.beans.value.ObservableValue<? extends javafx.geometry.NodeOrientation> obsrv1NodeOrientation;
    private javafx.beans.property.Property<javafx.geometry.NodeOrientation> obsrv2NodeOrientation;

    private boolean bound1OnContextMenuRequested;
    private boolean bound2OnContextMenuRequested;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ContextMenuEvent>> obsrv1OnContextMenuRequested;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.ContextMenuEvent>> obsrv2OnContextMenuRequested;

    private boolean bound1OnDragDetected;
    private boolean bound2OnDragDetected;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrv1OnDragDetected;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrv2OnDragDetected;

    private boolean bound1OnDragDone;
    private boolean bound2OnDragDone;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> obsrv1OnDragDone;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> obsrv2OnDragDone;

    private boolean bound1OnDragDropped;
    private boolean bound2OnDragDropped;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> obsrv1OnDragDropped;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> obsrv2OnDragDropped;

    private boolean bound1OnDragEntered;
    private boolean bound2OnDragEntered;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> obsrv1OnDragEntered;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> obsrv2OnDragEntered;

    private boolean bound1OnDragExited;
    private boolean bound2OnDragExited;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> obsrv1OnDragExited;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> obsrv2OnDragExited;

    private boolean bound1OnDragOver;
    private boolean bound2OnDragOver;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> obsrv1OnDragOver;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> obsrv2OnDragOver;

    private boolean bound1OnInputMethodTextChanged;
    private boolean bound2OnInputMethodTextChanged;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.InputMethodEvent>> obsrv1OnInputMethodTextChanged;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.InputMethodEvent>> obsrv2OnInputMethodTextChanged;

    private boolean bound1OnKeyPressed;
    private boolean bound2OnKeyPressed;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.KeyEvent>> obsrv1OnKeyPressed;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.KeyEvent>> obsrv2OnKeyPressed;

    private boolean bound1OnKeyReleased;
    private boolean bound2OnKeyReleased;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.KeyEvent>> obsrv1OnKeyReleased;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.KeyEvent>> obsrv2OnKeyReleased;

    private boolean bound1OnKeyTyped;
    private boolean bound2OnKeyTyped;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.KeyEvent>> obsrv1OnKeyTyped;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.KeyEvent>> obsrv2OnKeyTyped;

    private boolean bound1OnMouseClicked;
    private boolean bound2OnMouseClicked;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrv1OnMouseClicked;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrv2OnMouseClicked;

    private boolean bound1OnMouseDragEntered;
    private boolean bound2OnMouseDragEntered;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> obsrv1OnMouseDragEntered;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> obsrv2OnMouseDragEntered;

    private boolean bound1OnMouseDragExited;
    private boolean bound2OnMouseDragExited;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> obsrv1OnMouseDragExited;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> obsrv2OnMouseDragExited;

    private boolean bound1OnMouseDragOver;
    private boolean bound2OnMouseDragOver;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> obsrv1OnMouseDragOver;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> obsrv2OnMouseDragOver;

    private boolean bound1OnMouseDragReleased;
    private boolean bound2OnMouseDragReleased;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> obsrv1OnMouseDragReleased;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> obsrv2OnMouseDragReleased;

    private boolean bound1OnMouseDragged;
    private boolean bound2OnMouseDragged;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrv1OnMouseDragged;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrv2OnMouseDragged;

    private boolean bound1OnMouseEntered;
    private boolean bound2OnMouseEntered;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrv1OnMouseEntered;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrv2OnMouseEntered;

    private boolean bound1OnMouseExited;
    private boolean bound2OnMouseExited;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrv1OnMouseExited;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrv2OnMouseExited;

    private boolean bound1OnMouseMoved;
    private boolean bound2OnMouseMoved;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrv1OnMouseMoved;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrv2OnMouseMoved;

    private boolean bound1OnMousePressed;
    private boolean bound2OnMousePressed;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrv1OnMousePressed;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrv2OnMousePressed;

    private boolean bound1OnMouseReleased;
    private boolean bound2OnMouseReleased;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrv1OnMouseReleased;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrv2OnMouseReleased;

    private boolean bound1OnRotate;
    private boolean bound2OnRotate;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.RotateEvent>> obsrv1OnRotate;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.RotateEvent>> obsrv2OnRotate;

    private boolean bound1OnRotationFinished;
    private boolean bound2OnRotationFinished;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.RotateEvent>> obsrv1OnRotationFinished;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.RotateEvent>> obsrv2OnRotationFinished;

    private boolean bound1OnRotationStarted;
    private boolean bound2OnRotationStarted;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.RotateEvent>> obsrv1OnRotationStarted;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.RotateEvent>> obsrv2OnRotationStarted;

    private boolean bound1OnScrollFinished;
    private boolean bound2OnScrollFinished;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent>> obsrv1OnScrollFinished;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent>> obsrv2OnScrollFinished;

    private boolean bound1OnScroll;
    private boolean bound2OnScroll;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent>> obsrv1OnScroll;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent>> obsrv2OnScroll;

    private boolean bound1OnScrollStarted;
    private boolean bound2OnScrollStarted;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent>> obsrv1OnScrollStarted;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent>> obsrv2OnScrollStarted;

    private boolean bound1OnSwipeDown;
    private boolean bound2OnSwipeDown;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> obsrv1OnSwipeDown;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> obsrv2OnSwipeDown;

    private boolean bound1OnSwipeLeft;
    private boolean bound2OnSwipeLeft;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> obsrv1OnSwipeLeft;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> obsrv2OnSwipeLeft;

    private boolean bound1OnSwipeRight;
    private boolean bound2OnSwipeRight;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> obsrv1OnSwipeRight;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> obsrv2OnSwipeRight;

    private boolean bound1OnSwipeUp;
    private boolean bound2OnSwipeUp;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> obsrv1OnSwipeUp;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> obsrv2OnSwipeUp;

    private boolean bound1OnTouchMoved;
    private boolean bound2OnTouchMoved;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> obsrv1OnTouchMoved;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> obsrv2OnTouchMoved;

    private boolean bound1OnTouchPressed;
    private boolean bound2OnTouchPressed;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> obsrv1OnTouchPressed;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> obsrv2OnTouchPressed;

    private boolean bound1OnTouchReleased;
    private boolean bound2OnTouchReleased;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> obsrv1OnTouchReleased;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> obsrv2OnTouchReleased;

    private boolean bound1OnTouchStationary;
    private boolean bound2OnTouchStationary;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> obsrv1OnTouchStationary;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> obsrv2OnTouchStationary;

    private boolean bound1OnZoomFinished;
    private boolean bound2OnZoomFinished;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent>> obsrv1OnZoomFinished;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent>> obsrv2OnZoomFinished;

    private boolean bound1OnZoom;
    private boolean bound2OnZoom;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent>> obsrv1OnZoom;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent>> obsrv2OnZoom;

    private boolean bound1OnZoomStarted;
    private boolean bound2OnZoomStarted;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent>> obsrv1OnZoomStarted;
    private javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent>> obsrv2OnZoomStarted;

    private boolean bound1Opacity;
    private boolean bound2Opacity;
    private javafx.beans.value.ObservableValue<? extends Number> obsrv1Opacity;
    private javafx.beans.property.Property<Number> obsrv2Opacity;

    private boolean bound1PickOnBounds;
    private boolean bound2PickOnBounds;
    private javafx.beans.value.ObservableValue<? extends Boolean> obsrv1PickOnBounds;
    private javafx.beans.property.Property<Boolean> obsrv2PickOnBounds;

    private boolean bound1Rotate;
    private boolean bound2Rotate;
    private javafx.beans.value.ObservableValue<? extends Number> obsrv1Rotate;
    private javafx.beans.property.Property<Number> obsrv2Rotate;

    private boolean bound1RotationAxis;
    private boolean bound2RotationAxis;
    private javafx.beans.value.ObservableValue<? extends javafx.geometry.Point3D> obsrv1RotationAxis;
    private javafx.beans.property.Property<javafx.geometry.Point3D> obsrv2RotationAxis;

    private boolean bound1ScaleX;
    private boolean bound2ScaleX;
    private javafx.beans.value.ObservableValue<? extends Number> obsrv1ScaleX;
    private javafx.beans.property.Property<Number> obsrv2ScaleX;

    private boolean bound1ScaleY;
    private boolean bound2ScaleY;
    private javafx.beans.value.ObservableValue<? extends Number> obsrv1ScaleY;
    private javafx.beans.property.Property<Number> obsrv2ScaleY;

    private boolean bound1ScaleZ;
    private boolean bound2ScaleZ;
    private javafx.beans.value.ObservableValue<? extends Number> obsrv1ScaleZ;
    private javafx.beans.property.Property<Number> obsrv2ScaleZ;

    private boolean bound1Style;
    private boolean bound2Style;
    private javafx.beans.value.ObservableValue<? extends String> obsrv1Style;
    private javafx.beans.property.Property<String> obsrv2Style;

    private boolean bound1TranslateX;
    private boolean bound2TranslateX;
    private javafx.beans.value.ObservableValue<? extends Number> obsrv1TranslateX;
    private javafx.beans.property.Property<Number> obsrv2TranslateX;

    private boolean bound1TranslateY;
    private boolean bound2TranslateY;
    private javafx.beans.value.ObservableValue<? extends Number> obsrv1TranslateY;
    private javafx.beans.property.Property<Number> obsrv2TranslateY;

    private boolean bound1TranslateZ;
    private boolean bound2TranslateZ;
    private javafx.beans.value.ObservableValue<? extends Number> obsrv1TranslateZ;
    private javafx.beans.property.Property<Number> obsrv2TranslateZ;

    private boolean bound1Visible;
    private boolean bound2Visible;
    private javafx.beans.value.ObservableValue<? extends Boolean> obsrv1Visible;
    private javafx.beans.property.Property<Boolean> obsrv2Visible;

    @Override
    public void applyTo(Z instance)
    {
        super.applyTo(instance);
        if (this.hasBlendMode)
            instance.setBlendMode(this.valBlendMode);
        if (this.hasCache)
            instance.setCache(this.valCache);
        if (this.hasCacheHint)
            instance.setCacheHint(this.valCacheHint);
        if (this.hasClip)
            instance.setClip(this.valClip);
        if (this.hasCursor)
            instance.setCursor(this.valCursor);
        if (this.hasDepthTest)
            instance.setDepthTest(this.valDepthTest);
        if (this.hasDisable)
            instance.setDisable(this.valDisable);
        if (this.hasEffect)
            instance.setEffect(this.valEffect);
        if (this.hasEventDispatcher)
            instance.setEventDispatcher(this.valEventDispatcher);
        if (this.hasFocusTraversable)
            instance.setFocusTraversable(this.valFocusTraversable);
        if (this.hasId)
            instance.setId(this.valId);
        if (this.hasInputMethodRequests)
            instance.setInputMethodRequests(this.valInputMethodRequests);
        if (this.hasLayoutX)
            instance.setLayoutX(this.valLayoutX);
        if (this.hasLayoutY)
            instance.setLayoutY(this.valLayoutY);
        if (this.hasManaged)
            instance.setManaged(this.valManaged);
        if (this.hasMouseTransparent)
            instance.setMouseTransparent(this.valMouseTransparent);
        if (this.hasNodeOrientation)
            instance.setNodeOrientation(this.valNodeOrientation);
        if (this.hasOnContextMenuRequested)
            instance.setOnContextMenuRequested(this.valOnContextMenuRequested);
        if (this.hasOnDragDetected)
            instance.setOnDragDetected(this.valOnDragDetected);
        if (this.hasOnDragDone)
            instance.setOnDragDone(this.valOnDragDone);
        if (this.hasOnDragDropped)
            instance.setOnDragDropped(this.valOnDragDropped);
        if (this.hasOnDragEntered)
            instance.setOnDragEntered(this.valOnDragEntered);
        if (this.hasOnDragExited)
            instance.setOnDragExited(this.valOnDragExited);
        if (this.hasOnDragOver)
            instance.setOnDragOver(this.valOnDragOver);
        if (this.hasOnInputMethodTextChanged)
            instance.setOnInputMethodTextChanged(this.valOnInputMethodTextChanged);
        if (this.hasOnKeyPressed)
            instance.setOnKeyPressed(this.valOnKeyPressed);
        if (this.hasOnKeyReleased)
            instance.setOnKeyReleased(this.valOnKeyReleased);
        if (this.hasOnKeyTyped)
            instance.setOnKeyTyped(this.valOnKeyTyped);
        if (this.hasOnMouseClicked)
            instance.setOnMouseClicked(this.valOnMouseClicked);
        if (this.hasOnMouseDragEntered)
            instance.setOnMouseDragEntered(this.valOnMouseDragEntered);
        if (this.hasOnMouseDragExited)
            instance.setOnMouseDragExited(this.valOnMouseDragExited);
        if (this.hasOnMouseDragOver)
            instance.setOnMouseDragOver(this.valOnMouseDragOver);
        if (this.hasOnMouseDragReleased)
            instance.setOnMouseDragReleased(this.valOnMouseDragReleased);
        if (this.hasOnMouseDragged)
            instance.setOnMouseDragged(this.valOnMouseDragged);
        if (this.hasOnMouseEntered)
            instance.setOnMouseEntered(this.valOnMouseEntered);
        if (this.hasOnMouseExited)
            instance.setOnMouseExited(this.valOnMouseExited);
        if (this.hasOnMouseMoved)
            instance.setOnMouseMoved(this.valOnMouseMoved);
        if (this.hasOnMousePressed)
            instance.setOnMousePressed(this.valOnMousePressed);
        if (this.hasOnMouseReleased)
            instance.setOnMouseReleased(this.valOnMouseReleased);
        if (this.hasOnRotate)
            instance.setOnRotate(this.valOnRotate);
        if (this.hasOnRotationFinished)
            instance.setOnRotationFinished(this.valOnRotationFinished);
        if (this.hasOnRotationStarted)
            instance.setOnRotationStarted(this.valOnRotationStarted);
        if (this.hasOnScroll)
            instance.setOnScroll(this.valOnScroll);
        if (this.hasOnScrollFinished)
            instance.setOnScrollFinished(this.valOnScrollFinished);
        if (this.hasOnScrollStarted)
            instance.setOnScrollStarted(this.valOnScrollStarted);
        if (this.hasOnSwipeDown)
            instance.setOnSwipeDown(this.valOnSwipeDown);
        if (this.hasOnSwipeLeft)
            instance.setOnSwipeLeft(this.valOnSwipeLeft);
        if (this.hasOnSwipeRight)
            instance.setOnSwipeRight(this.valOnSwipeRight);
        if (this.hasOnSwipeUp)
            instance.setOnSwipeUp(this.valOnSwipeUp);
        if (this.hasOnTouchMoved)
            instance.setOnTouchMoved(this.valOnTouchMoved);
        if (this.hasOnTouchPressed)
            instance.setOnTouchPressed(this.valOnTouchPressed);
        if (this.hasOnTouchReleased)
            instance.setOnTouchReleased(this.valOnTouchReleased);
        if (this.hasOnTouchStationary)
            instance.setOnTouchStationary(this.valOnTouchStationary);
        if (this.hasOnZoom)
            instance.setOnZoom(this.valOnZoom);
        if (this.hasOnZoomFinished)
            instance.setOnZoomFinished(this.valOnZoomFinished);
        if (this.hasOnZoomStarted)
            instance.setOnZoomStarted(this.valOnZoomStarted);
        if (this.hasOpacity)
            instance.setOpacity(this.valOpacity);
        if (this.hasPickOnBounds)
            instance.setPickOnBounds(this.valPickOnBounds);
        if (this.hasRotate)
            instance.setRotate(this.valRotate);
        if (this.hasRotationAxis)
            instance.setRotationAxis(this.valRotationAxis);
        if (this.hasScaleX)
            instance.setScaleX(this.valScaleX);
        if (this.hasScaleY)
            instance.setScaleY(this.valScaleY);
        if (this.hasScaleZ)
            instance.setScaleZ(this.valScaleZ);
        if (this.hasStyle)
            instance.setStyle(this.valStyle);
        if (this.hasStyleClass)
            instance.getStyleClass().setAll(this.valStyleClass);
        if (this.hasTransforms)
            instance.getTransforms().setAll(this.valTransforms);
        if (this.hasTranslateX)
            instance.setTranslateX(this.valTranslateX);
        if (this.hasTranslateY)
            instance.setTranslateY(this.valTranslateY);
        if (this.hasTranslateZ)
            instance.setTranslateZ(this.valTranslateZ);
        if (this.hasUserData)
            instance.setUserData(this.valUserData);
        if (this.hasVisible)
            instance.setVisible(this.valVisible);
        if (this.hasAnchorPane_bottomAnchor)
            javafx.scene.layout.AnchorPane.setBottomAnchor(instance, this.valAnchorPane_bottomAnchor);
        if (this.hasAnchorPane_leftAnchor)
            javafx.scene.layout.AnchorPane.setLeftAnchor(instance, this.valAnchorPane_leftAnchor);
        if (this.hasAnchorPane_rightAnchor)
            javafx.scene.layout.AnchorPane.setRightAnchor(instance, this.valAnchorPane_rightAnchor);
        if (this.hasAnchorPane_topAnchor)
            javafx.scene.layout.AnchorPane.setTopAnchor(instance, this.valAnchorPane_topAnchor);
        if (this.hasBorderPane_alignment)
            javafx.scene.layout.BorderPane.setAlignment(instance, this.valBorderPane_alignment);
        if (this.hasBorderPane_margin)
            javafx.scene.layout.BorderPane.setMargin(instance, this.valBorderPane_margin);
        if (this.hasFlowPane_margin)
            javafx.scene.layout.FlowPane.setMargin(instance, this.valFlowPane_margin);
        if (this.hasGridPane_columnIndex)
            javafx.scene.layout.GridPane.setColumnIndex(instance, this.valGridPane_columnIndex);
        if (this.hasGridPane_columnSpan)
            javafx.scene.layout.GridPane.setColumnSpan(instance, this.valGridPane_columnSpan);
        if (this.hasGridPane_fillHeight)
            javafx.scene.layout.GridPane.setFillHeight(instance, this.valGridPane_fillHeight);
        if (this.hasGridPane_fillWidth)
            javafx.scene.layout.GridPane.setFillWidth(instance, this.valGridPane_fillWidth);
        if (this.hasGridPane_halignment)
            javafx.scene.layout.GridPane.setHalignment(instance, this.valGridPane_halignment);
        if (this.hasGridPane_hgrow)
            javafx.scene.layout.GridPane.setHgrow(instance, this.valGridPane_hgrow);
        if (this.hasGridPane_margin)
            javafx.scene.layout.GridPane.setMargin(instance, this.valGridPane_margin);
        if (this.hasGridPane_rowIndex)
            javafx.scene.layout.GridPane.setRowIndex(instance, this.valGridPane_rowIndex);
        if (this.hasGridPane_rowSpan)
            javafx.scene.layout.GridPane.setRowSpan(instance, this.valGridPane_rowSpan);
        if (this.hasGridPane_valignment)
            javafx.scene.layout.GridPane.setValignment(instance, this.valGridPane_valignment);
        if (this.hasGridPane_vgrow)
            javafx.scene.layout.GridPane.setVgrow(instance, this.valGridPane_vgrow);
        if (this.hasHBox_hgrow)
            javafx.scene.layout.HBox.setHgrow(instance, this.valHBox_hgrow);
        if (this.hasHBox_margin)
            javafx.scene.layout.HBox.setMargin(instance, this.valHBox_margin);
        if (this.hasSplitPane_resizableWithParent)
            javafx.scene.control.SplitPane.setResizableWithParent(instance, this.valSplitPane_resizableWithParent);
        if (this.hasStackPane_alignment)
            javafx.scene.layout.StackPane.setAlignment(instance, this.valStackPane_alignment);
        if (this.hasStackPane_margin)
            javafx.scene.layout.StackPane.setMargin(instance, this.valStackPane_margin);
        if (this.hasTilePane_alignment)
            javafx.scene.layout.TilePane.setAlignment(instance, this.valTilePane_alignment);
        if (this.hasTilePane_margin)
            javafx.scene.layout.TilePane.setMargin(instance, this.valTilePane_margin);
        if (this.hasVBox_margin)
            javafx.scene.layout.VBox.setMargin(instance, this.valVBox_margin);
        if (this.hasVBox_vgrow)
            javafx.scene.layout.VBox.setVgrow(instance, this.valVBox_vgrow);
        if (this.bound1BlendMode)
            instance.blendModeProperty().bind(this.obsrv1BlendMode);
        if (this.bound2BlendMode)
            instance.blendModeProperty().bindBidirectional(this.obsrv2BlendMode);
        if (this.bound1CacheHint)
            instance.cacheHintProperty().bind(this.obsrv1CacheHint);
        if (this.bound2CacheHint)
            instance.cacheHintProperty().bindBidirectional(this.obsrv2CacheHint);
        if (this.bound1Cache)
            instance.cacheProperty().bind(this.obsrv1Cache);
        if (this.bound2Cache)
            instance.cacheProperty().bindBidirectional(this.obsrv2Cache);
        if (this.bound1Clip)
            instance.clipProperty().bind(this.obsrv1Clip);
        if (this.bound2Clip)
            instance.clipProperty().bindBidirectional(this.obsrv2Clip);
        if (this.bound1Cursor)
            instance.cursorProperty().bind(this.obsrv1Cursor);
        if (this.bound2Cursor)
            instance.cursorProperty().bindBidirectional(this.obsrv2Cursor);
        if (this.bound1DepthTest)
            instance.depthTestProperty().bind(this.obsrv1DepthTest);
        if (this.bound2DepthTest)
            instance.depthTestProperty().bindBidirectional(this.obsrv2DepthTest);
        if (this.bound1Disable)
            instance.disableProperty().bind(this.obsrv1Disable);
        if (this.bound2Disable)
            instance.disableProperty().bindBidirectional(this.obsrv2Disable);
        if (this.bound1Effect)
            instance.effectProperty().bind(this.obsrv1Effect);
        if (this.bound2Effect)
            instance.effectProperty().bindBidirectional(this.obsrv2Effect);
        if (this.bound1EventDispatcher)
            instance.eventDispatcherProperty().bind(this.obsrv1EventDispatcher);
        if (this.bound2EventDispatcher)
            instance.eventDispatcherProperty().bindBidirectional(this.obsrv2EventDispatcher);
        if (this.bound1FocusTraversable)
            instance.focusTraversableProperty().bind(this.obsrv1FocusTraversable);
        if (this.bound2FocusTraversable)
            instance.focusTraversableProperty().bindBidirectional(this.obsrv2FocusTraversable);
        if (this.bound1Id)
            instance.idProperty().bind(this.obsrv1Id);
        if (this.bound2Id)
            instance.idProperty().bindBidirectional(this.obsrv2Id);
        if (this.bound1InputMethodRequests)
            instance.inputMethodRequestsProperty().bind(this.obsrv1InputMethodRequests);
        if (this.bound2InputMethodRequests)
            instance.inputMethodRequestsProperty().bindBidirectional(this.obsrv2InputMethodRequests);
        if (this.bound1LayoutX)
            instance.layoutXProperty().bind(this.obsrv1LayoutX);
        if (this.bound2LayoutX)
            instance.layoutXProperty().bindBidirectional(this.obsrv2LayoutX);
        if (this.bound1LayoutY)
            instance.layoutYProperty().bind(this.obsrv1LayoutY);
        if (this.bound2LayoutY)
            instance.layoutYProperty().bindBidirectional(this.obsrv2LayoutY);
        if (this.bound1Managed)
            instance.managedProperty().bind(this.obsrv1Managed);
        if (this.bound2Managed)
            instance.managedProperty().bindBidirectional(this.obsrv2Managed);
        if (this.bound1MouseTransparent)
            instance.mouseTransparentProperty().bind(this.obsrv1MouseTransparent);
        if (this.bound2MouseTransparent)
            instance.mouseTransparentProperty().bindBidirectional(this.obsrv2MouseTransparent);
        if (this.bound1NodeOrientation)
            instance.nodeOrientationProperty().bind(this.obsrv1NodeOrientation);
        if (this.bound2NodeOrientation)
            instance.nodeOrientationProperty().bindBidirectional(this.obsrv2NodeOrientation);
        if (this.bound1OnContextMenuRequested)
            instance.onContextMenuRequestedProperty().bind(this.obsrv1OnContextMenuRequested);
        if (this.bound2OnContextMenuRequested)
            instance.onContextMenuRequestedProperty().bindBidirectional(this.obsrv2OnContextMenuRequested);
        if (this.bound1OnDragDetected)
            instance.onDragDetectedProperty().bind(this.obsrv1OnDragDetected);
        if (this.bound2OnDragDetected)
            instance.onDragDetectedProperty().bindBidirectional(this.obsrv2OnDragDetected);
        if (this.bound1OnDragDone)
            instance.onDragDoneProperty().bind(this.obsrv1OnDragDone);
        if (this.bound2OnDragDone)
            instance.onDragDoneProperty().bindBidirectional(this.obsrv2OnDragDone);
        if (this.bound1OnDragDropped)
            instance.onDragDroppedProperty().bind(this.obsrv1OnDragDropped);
        if (this.bound2OnDragDropped)
            instance.onDragDroppedProperty().bindBidirectional(this.obsrv2OnDragDropped);
        if (this.bound1OnDragEntered)
            instance.onDragEnteredProperty().bind(this.obsrv1OnDragEntered);
        if (this.bound2OnDragEntered)
            instance.onDragEnteredProperty().bindBidirectional(this.obsrv2OnDragEntered);
        if (this.bound1OnDragExited)
            instance.onDragExitedProperty().bind(this.obsrv1OnDragExited);
        if (this.bound2OnDragExited)
            instance.onDragExitedProperty().bindBidirectional(this.obsrv2OnDragExited);
        if (this.bound1OnDragOver)
            instance.onDragOverProperty().bind(this.obsrv1OnDragOver);
        if (this.bound2OnDragOver)
            instance.onDragOverProperty().bindBidirectional(this.obsrv2OnDragOver);
        if (this.bound1OnInputMethodTextChanged)
            instance.onInputMethodTextChangedProperty().bind(this.obsrv1OnInputMethodTextChanged);
        if (this.bound2OnInputMethodTextChanged)
            instance.onInputMethodTextChangedProperty().bindBidirectional(this.obsrv2OnInputMethodTextChanged);
        if (this.bound1OnKeyPressed)
            instance.onKeyPressedProperty().bind(this.obsrv1OnKeyPressed);
        if (this.bound2OnKeyPressed)
            instance.onKeyPressedProperty().bindBidirectional(this.obsrv2OnKeyPressed);
        if (this.bound1OnKeyReleased)
            instance.onKeyReleasedProperty().bind(this.obsrv1OnKeyReleased);
        if (this.bound2OnKeyReleased)
            instance.onKeyReleasedProperty().bindBidirectional(this.obsrv2OnKeyReleased);
        if (this.bound1OnKeyTyped)
            instance.onKeyTypedProperty().bind(this.obsrv1OnKeyTyped);
        if (this.bound2OnKeyTyped)
            instance.onKeyTypedProperty().bindBidirectional(this.obsrv2OnKeyTyped);
        if (this.bound1OnMouseClicked)
            instance.onMouseClickedProperty().bind(this.obsrv1OnMouseClicked);
        if (this.bound2OnMouseClicked)
            instance.onMouseClickedProperty().bindBidirectional(this.obsrv2OnMouseClicked);
        if (this.bound1OnMouseDragEntered)
            instance.onMouseDragEnteredProperty().bind(this.obsrv1OnMouseDragEntered);
        if (this.bound2OnMouseDragEntered)
            instance.onMouseDragEnteredProperty().bindBidirectional(this.obsrv2OnMouseDragEntered);
        if (this.bound1OnMouseDragExited)
            instance.onMouseDragExitedProperty().bind(this.obsrv1OnMouseDragExited);
        if (this.bound2OnMouseDragExited)
            instance.onMouseDragExitedProperty().bindBidirectional(this.obsrv2OnMouseDragExited);
        if (this.bound1OnMouseDragOver)
            instance.onMouseDragOverProperty().bind(this.obsrv1OnMouseDragOver);
        if (this.bound2OnMouseDragOver)
            instance.onMouseDragOverProperty().bindBidirectional(this.obsrv2OnMouseDragOver);
        if (this.bound1OnMouseDragReleased)
            instance.onMouseDragReleasedProperty().bind(this.obsrv1OnMouseDragReleased);
        if (this.bound2OnMouseDragReleased)
            instance.onMouseDragReleasedProperty().bindBidirectional(this.obsrv2OnMouseDragReleased);
        if (this.bound1OnMouseDragged)
            instance.onMouseDraggedProperty().bind(this.obsrv1OnMouseDragged);
        if (this.bound2OnMouseDragged)
            instance.onMouseDraggedProperty().bindBidirectional(this.obsrv2OnMouseDragged);
        if (this.bound1OnMouseEntered)
            instance.onMouseEnteredProperty().bind(this.obsrv1OnMouseEntered);
        if (this.bound2OnMouseEntered)
            instance.onMouseEnteredProperty().bindBidirectional(this.obsrv2OnMouseEntered);
        if (this.bound1OnMouseExited)
            instance.onMouseExitedProperty().bind(this.obsrv1OnMouseExited);
        if (this.bound2OnMouseExited)
            instance.onMouseExitedProperty().bindBidirectional(this.obsrv2OnMouseExited);
        if (this.bound1OnMouseMoved)
            instance.onMouseMovedProperty().bind(this.obsrv1OnMouseMoved);
        if (this.bound2OnMouseMoved)
            instance.onMouseMovedProperty().bindBidirectional(this.obsrv2OnMouseMoved);
        if (this.bound1OnMousePressed)
            instance.onMousePressedProperty().bind(this.obsrv1OnMousePressed);
        if (this.bound2OnMousePressed)
            instance.onMousePressedProperty().bindBidirectional(this.obsrv2OnMousePressed);
        if (this.bound1OnMouseReleased)
            instance.onMouseReleasedProperty().bind(this.obsrv1OnMouseReleased);
        if (this.bound2OnMouseReleased)
            instance.onMouseReleasedProperty().bindBidirectional(this.obsrv2OnMouseReleased);
        if (this.bound1OnRotate)
            instance.onRotateProperty().bind(this.obsrv1OnRotate);
        if (this.bound2OnRotate)
            instance.onRotateProperty().bindBidirectional(this.obsrv2OnRotate);
        if (this.bound1OnRotationFinished)
            instance.onRotationFinishedProperty().bind(this.obsrv1OnRotationFinished);
        if (this.bound2OnRotationFinished)
            instance.onRotationFinishedProperty().bindBidirectional(this.obsrv2OnRotationFinished);
        if (this.bound1OnRotationStarted)
            instance.onRotationStartedProperty().bind(this.obsrv1OnRotationStarted);
        if (this.bound2OnRotationStarted)
            instance.onRotationStartedProperty().bindBidirectional(this.obsrv2OnRotationStarted);
        if (this.bound1OnScrollFinished)
            instance.onScrollFinishedProperty().bind(this.obsrv1OnScrollFinished);
        if (this.bound2OnScrollFinished)
            instance.onScrollFinishedProperty().bindBidirectional(this.obsrv2OnScrollFinished);
        if (this.bound1OnScroll)
            instance.onScrollProperty().bind(this.obsrv1OnScroll);
        if (this.bound2OnScroll)
            instance.onScrollProperty().bindBidirectional(this.obsrv2OnScroll);
        if (this.bound1OnScrollStarted)
            instance.onScrollStartedProperty().bind(this.obsrv1OnScrollStarted);
        if (this.bound2OnScrollStarted)
            instance.onScrollStartedProperty().bindBidirectional(this.obsrv2OnScrollStarted);
        if (this.bound1OnSwipeDown)
            instance.onSwipeDownProperty().bind(this.obsrv1OnSwipeDown);
        if (this.bound2OnSwipeDown)
            instance.onSwipeDownProperty().bindBidirectional(this.obsrv2OnSwipeDown);
        if (this.bound1OnSwipeLeft)
            instance.onSwipeLeftProperty().bind(this.obsrv1OnSwipeLeft);
        if (this.bound2OnSwipeLeft)
            instance.onSwipeLeftProperty().bindBidirectional(this.obsrv2OnSwipeLeft);
        if (this.bound1OnSwipeRight)
            instance.onSwipeRightProperty().bind(this.obsrv1OnSwipeRight);
        if (this.bound2OnSwipeRight)
            instance.onSwipeRightProperty().bindBidirectional(this.obsrv2OnSwipeRight);
        if (this.bound1OnSwipeUp)
            instance.onSwipeUpProperty().bind(this.obsrv1OnSwipeUp);
        if (this.bound2OnSwipeUp)
            instance.onSwipeUpProperty().bindBidirectional(this.obsrv2OnSwipeUp);
        if (this.bound1OnTouchMoved)
            instance.onTouchMovedProperty().bind(this.obsrv1OnTouchMoved);
        if (this.bound2OnTouchMoved)
            instance.onTouchMovedProperty().bindBidirectional(this.obsrv2OnTouchMoved);
        if (this.bound1OnTouchPressed)
            instance.onTouchPressedProperty().bind(this.obsrv1OnTouchPressed);
        if (this.bound2OnTouchPressed)
            instance.onTouchPressedProperty().bindBidirectional(this.obsrv2OnTouchPressed);
        if (this.bound1OnTouchReleased)
            instance.onTouchReleasedProperty().bind(this.obsrv1OnTouchReleased);
        if (this.bound2OnTouchReleased)
            instance.onTouchReleasedProperty().bindBidirectional(this.obsrv2OnTouchReleased);
        if (this.bound1OnTouchStationary)
            instance.onTouchStationaryProperty().bind(this.obsrv1OnTouchStationary);
        if (this.bound2OnTouchStationary)
            instance.onTouchStationaryProperty().bindBidirectional(this.obsrv2OnTouchStationary);
        if (this.bound1OnZoomFinished)
            instance.onZoomFinishedProperty().bind(this.obsrv1OnZoomFinished);
        if (this.bound2OnZoomFinished)
            instance.onZoomFinishedProperty().bindBidirectional(this.obsrv2OnZoomFinished);
        if (this.bound1OnZoom)
            instance.onZoomProperty().bind(this.obsrv1OnZoom);
        if (this.bound2OnZoom)
            instance.onZoomProperty().bindBidirectional(this.obsrv2OnZoom);
        if (this.bound1OnZoomStarted)
            instance.onZoomStartedProperty().bind(this.obsrv1OnZoomStarted);
        if (this.bound2OnZoomStarted)
            instance.onZoomStartedProperty().bindBidirectional(this.obsrv2OnZoomStarted);
        if (this.bound1Opacity)
            instance.opacityProperty().bind(this.obsrv1Opacity);
        if (this.bound2Opacity)
            instance.opacityProperty().bindBidirectional(this.obsrv2Opacity);
        if (this.bound1PickOnBounds)
            instance.pickOnBoundsProperty().bind(this.obsrv1PickOnBounds);
        if (this.bound2PickOnBounds)
            instance.pickOnBoundsProperty().bindBidirectional(this.obsrv2PickOnBounds);
        if (this.bound1Rotate)
            instance.rotateProperty().bind(this.obsrv1Rotate);
        if (this.bound2Rotate)
            instance.rotateProperty().bindBidirectional(this.obsrv2Rotate);
        if (this.bound1RotationAxis)
            instance.rotationAxisProperty().bind(this.obsrv1RotationAxis);
        if (this.bound2RotationAxis)
            instance.rotationAxisProperty().bindBidirectional(this.obsrv2RotationAxis);
        if (this.bound1ScaleX)
            instance.scaleXProperty().bind(this.obsrv1ScaleX);
        if (this.bound2ScaleX)
            instance.scaleXProperty().bindBidirectional(this.obsrv2ScaleX);
        if (this.bound1ScaleY)
            instance.scaleYProperty().bind(this.obsrv1ScaleY);
        if (this.bound2ScaleY)
            instance.scaleYProperty().bindBidirectional(this.obsrv2ScaleY);
        if (this.bound1ScaleZ)
            instance.scaleZProperty().bind(this.obsrv1ScaleZ);
        if (this.bound2ScaleZ)
            instance.scaleZProperty().bindBidirectional(this.obsrv2ScaleZ);
        if (this.bound1Style)
            instance.styleProperty().bind(this.obsrv1Style);
        if (this.bound2Style)
            instance.styleProperty().bindBidirectional(this.obsrv2Style);
        if (this.bound1TranslateX)
            instance.translateXProperty().bind(this.obsrv1TranslateX);
        if (this.bound2TranslateX)
            instance.translateXProperty().bindBidirectional(this.obsrv2TranslateX);
        if (this.bound1TranslateY)
            instance.translateYProperty().bind(this.obsrv1TranslateY);
        if (this.bound2TranslateY)
            instance.translateYProperty().bindBidirectional(this.obsrv2TranslateY);
        if (this.bound1TranslateZ)
            instance.translateZProperty().bind(this.obsrv1TranslateZ);
        if (this.bound2TranslateZ)
            instance.translateZProperty().bindBidirectional(this.obsrv2TranslateZ);
        if (this.bound1Visible)
            instance.visibleProperty().bind(this.obsrv1Visible);
        if (this.bound2Visible)
            instance.visibleProperty().bindBidirectional(this.obsrv2Visible);
    }

    /**
     * 設定屬性{@link Node#setBlendMode(javafx.scene.effect.BlendMode)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B blendMode(javafx.scene.effect.BlendMode value)
    {
        this.hasBlendMode = true;
        this.valBlendMode = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setCache(boolean)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B cache(boolean value)
    {
        this.hasCache = true;
        this.valCache = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setCacheHint(javafx.scene.CacheHint)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B cacheHint(javafx.scene.CacheHint value)
    {
        this.hasCacheHint = true;
        this.valCacheHint = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setClip(javafx.scene.Node)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B clip(javafx.scene.Node value)
    {
        this.hasClip = true;
        this.valClip = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setCursor(javafx.scene.Cursor)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B cursor(javafx.scene.Cursor value)
    {
        this.hasCursor = true;
        this.valCursor = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setDepthTest(javafx.scene.DepthTest)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B depthTest(javafx.scene.DepthTest value)
    {
        this.hasDepthTest = true;
        this.valDepthTest = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setDisable(boolean)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B disable(boolean value)
    {
        this.hasDisable = true;
        this.valDisable = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setEffect(javafx.scene.effect.Effect)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B effect(javafx.scene.effect.Effect value)
    {
        this.hasEffect = true;
        this.valEffect = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setEventDispatcher(javafx.event.EventDispatcher)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B eventDispatcher(javafx.event.EventDispatcher value)
    {
        this.hasEventDispatcher = true;
        this.valEventDispatcher = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setFocusTraversable(boolean)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B focusTraversable(boolean value)
    {
        this.hasFocusTraversable = true;
        this.valFocusTraversable = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setId(java.lang.String)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B id(java.lang.String value)
    {
        this.hasId = true;
        this.valId = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setInputMethodRequests(javafx.scene.input.InputMethodRequests)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B inputMethodRequests(javafx.scene.input.InputMethodRequests value)
    {
        this.hasInputMethodRequests = true;
        this.valInputMethodRequests = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setLayoutX(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B layoutX(double value)
    {
        this.hasLayoutX = true;
        this.valLayoutX = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setLayoutY(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B layoutY(double value)
    {
        this.hasLayoutY = true;
        this.valLayoutY = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setManaged(boolean)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B managed(boolean value)
    {
        this.hasManaged = true;
        this.valManaged = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setMouseTransparent(boolean)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B mouseTransparent(boolean value)
    {
        this.hasMouseTransparent = true;
        this.valMouseTransparent = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setNodeOrientation(javafx.geometry.NodeOrientation)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B nodeOrientation(javafx.geometry.NodeOrientation value)
    {
        this.hasNodeOrientation = true;
        this.valNodeOrientation = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnContextMenuRequested(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onContextMenuRequested(javafx.event.EventHandler<? super javafx.scene.input.ContextMenuEvent> value)
    {
        this.hasOnContextMenuRequested = true;
        this.valOnContextMenuRequested = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnDragDetected(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onDragDetected(javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> value)
    {
        this.hasOnDragDetected = true;
        this.valOnDragDetected = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnDragDone(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onDragDone(javafx.event.EventHandler<? super javafx.scene.input.DragEvent> value)
    {
        this.hasOnDragDone = true;
        this.valOnDragDone = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnDragDropped(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onDragDropped(javafx.event.EventHandler<? super javafx.scene.input.DragEvent> value)
    {
        this.hasOnDragDropped = true;
        this.valOnDragDropped = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnDragEntered(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onDragEntered(javafx.event.EventHandler<? super javafx.scene.input.DragEvent> value)
    {
        this.hasOnDragEntered = true;
        this.valOnDragEntered = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnDragExited(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onDragExited(javafx.event.EventHandler<? super javafx.scene.input.DragEvent> value)
    {
        this.hasOnDragExited = true;
        this.valOnDragExited = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnDragOver(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onDragOver(javafx.event.EventHandler<? super javafx.scene.input.DragEvent> value)
    {
        this.hasOnDragOver = true;
        this.valOnDragOver = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnInputMethodTextChanged(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onInputMethodTextChanged(javafx.event.EventHandler<? super javafx.scene.input.InputMethodEvent> value)
    {
        this.hasOnInputMethodTextChanged = true;
        this.valOnInputMethodTextChanged = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnKeyPressed(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onKeyPressed(javafx.event.EventHandler<? super javafx.scene.input.KeyEvent> value)
    {
        this.hasOnKeyPressed = true;
        this.valOnKeyPressed = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnKeyReleased(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onKeyReleased(javafx.event.EventHandler<? super javafx.scene.input.KeyEvent> value)
    {
        this.hasOnKeyReleased = true;
        this.valOnKeyReleased = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnKeyTyped(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onKeyTyped(javafx.event.EventHandler<? super javafx.scene.input.KeyEvent> value)
    {
        this.hasOnKeyTyped = true;
        this.valOnKeyTyped = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseClicked(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseClicked(javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> value)
    {
        this.hasOnMouseClicked = true;
        this.valOnMouseClicked = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseDragEntered(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseDragEntered(javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent> value)
    {
        this.hasOnMouseDragEntered = true;
        this.valOnMouseDragEntered = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseDragExited(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseDragExited(javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent> value)
    {
        this.hasOnMouseDragExited = true;
        this.valOnMouseDragExited = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseDragOver(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseDragOver(javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent> value)
    {
        this.hasOnMouseDragOver = true;
        this.valOnMouseDragOver = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseDragReleased(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseDragReleased(javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent> value)
    {
        this.hasOnMouseDragReleased = true;
        this.valOnMouseDragReleased = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseDragged(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseDragged(javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> value)
    {
        this.hasOnMouseDragged = true;
        this.valOnMouseDragged = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseEntered(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseEntered(javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> value)
    {
        this.hasOnMouseEntered = true;
        this.valOnMouseEntered = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseExited(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseExited(javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> value)
    {
        this.hasOnMouseExited = true;
        this.valOnMouseExited = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseMoved(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseMoved(javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> value)
    {
        this.hasOnMouseMoved = true;
        this.valOnMouseMoved = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMousePressed(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMousePressed(javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> value)
    {
        this.hasOnMousePressed = true;
        this.valOnMousePressed = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseReleased(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseReleased(javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> value)
    {
        this.hasOnMouseReleased = true;
        this.valOnMouseReleased = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnRotate(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onRotate(javafx.event.EventHandler<? super javafx.scene.input.RotateEvent> value)
    {
        this.hasOnRotate = true;
        this.valOnRotate = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnRotationFinished(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onRotationFinished(javafx.event.EventHandler<? super javafx.scene.input.RotateEvent> value)
    {
        this.hasOnRotationFinished = true;
        this.valOnRotationFinished = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnRotationStarted(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onRotationStarted(javafx.event.EventHandler<? super javafx.scene.input.RotateEvent> value)
    {
        this.hasOnRotationStarted = true;
        this.valOnRotationStarted = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnScroll(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onScroll(javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent> value)
    {
        this.hasOnScroll = true;
        this.valOnScroll = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnScrollFinished(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onScrollFinished(javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent> value)
    {
        this.hasOnScrollFinished = true;
        this.valOnScrollFinished = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnScrollStarted(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onScrollStarted(javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent> value)
    {
        this.hasOnScrollStarted = true;
        this.valOnScrollStarted = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnSwipeDown(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onSwipeDown(javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent> value)
    {
        this.hasOnSwipeDown = true;
        this.valOnSwipeDown = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnSwipeLeft(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onSwipeLeft(javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent> value)
    {
        this.hasOnSwipeLeft = true;
        this.valOnSwipeLeft = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnSwipeRight(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onSwipeRight(javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent> value)
    {
        this.hasOnSwipeRight = true;
        this.valOnSwipeRight = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnSwipeUp(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onSwipeUp(javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent> value)
    {
        this.hasOnSwipeUp = true;
        this.valOnSwipeUp = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnTouchMoved(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onTouchMoved(javafx.event.EventHandler<? super javafx.scene.input.TouchEvent> value)
    {
        this.hasOnTouchMoved = true;
        this.valOnTouchMoved = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnTouchPressed(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onTouchPressed(javafx.event.EventHandler<? super javafx.scene.input.TouchEvent> value)
    {
        this.hasOnTouchPressed = true;
        this.valOnTouchPressed = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnTouchReleased(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onTouchReleased(javafx.event.EventHandler<? super javafx.scene.input.TouchEvent> value)
    {
        this.hasOnTouchReleased = true;
        this.valOnTouchReleased = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnTouchStationary(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onTouchStationary(javafx.event.EventHandler<? super javafx.scene.input.TouchEvent> value)
    {
        this.hasOnTouchStationary = true;
        this.valOnTouchStationary = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnZoom(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onZoom(javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent> value)
    {
        this.hasOnZoom = true;
        this.valOnZoom = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnZoomFinished(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onZoomFinished(javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent> value)
    {
        this.hasOnZoomFinished = true;
        this.valOnZoomFinished = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnZoomStarted(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onZoomStarted(javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent> value)
    {
        this.hasOnZoomStarted = true;
        this.valOnZoomStarted = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOpacity(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B opacity(double value)
    {
        this.hasOpacity = true;
        this.valOpacity = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setPickOnBounds(boolean)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B pickOnBounds(boolean value)
    {
        this.hasPickOnBounds = true;
        this.valPickOnBounds = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setRotate(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B rotate(double value)
    {
        this.hasRotate = true;
        this.valRotate = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setRotationAxis(javafx.geometry.Point3D)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B rotationAxis(javafx.geometry.Point3D value)
    {
        this.hasRotationAxis = true;
        this.valRotationAxis = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setScaleX(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B scaleX(double value)
    {
        this.hasScaleX = true;
        this.valScaleX = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setScaleY(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B scaleY(double value)
    {
        this.hasScaleY = true;
        this.valScaleY = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setScaleZ(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B scaleZ(double value)
    {
        this.hasScaleZ = true;
        this.valScaleZ = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setStyle(java.lang.String)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B style(java.lang.String value)
    {
        this.hasStyle = true;
        this.valStyle = value;
        return (B) this;
    }

    /**
     * 設定集合屬性{@link Node#getStyleClass}的內容
     *
     * @param value 新的集合內容
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B styleClass(java.util.Collection<java.lang.String> value)
    {
        this.hasStyleClass = true;
        this.valStyleClass = value;
        return (B) this;
    }

    /**
     * 設定集合屬性{@link Node#getStyleClass}的內容
     *
     * @param value 新的集合內容
     * @return 目前的建構器(this)
     */
    @SafeVarargs
    @SuppressWarnings("unchecked")
    public final B styleClass(java.lang.String... value)
    {
        this.hasStyleClass = true;
        this.valStyleClass = java.util.Arrays.asList(value);
        return (B) this;
    }

    /**
     * 設定集合屬性{@link Node#getTransforms}的內容
     *
     * @param value 新的集合內容
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B transforms(java.util.Collection<javafx.scene.transform.Transform> value)
    {
        this.hasTransforms = true;
        this.valTransforms = value;
        return (B) this;
    }

    /**
     * 設定集合屬性{@link Node#getTransforms}的內容
     *
     * @param value 新的集合內容
     * @return 目前的建構器(this)
     */
    @SafeVarargs
    @SuppressWarnings("unchecked")
    public final B transforms(javafx.scene.transform.Transform... value)
    {
        this.hasTransforms = true;
        this.valTransforms = java.util.Arrays.asList(value);
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setTranslateX(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B translateX(double value)
    {
        this.hasTranslateX = true;
        this.valTranslateX = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setTranslateY(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B translateY(double value)
    {
        this.hasTranslateY = true;
        this.valTranslateY = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setTranslateZ(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B translateZ(double value)
    {
        this.hasTranslateZ = true;
        this.valTranslateZ = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setUserData(java.lang.Object)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B userData(java.lang.Object value)
    {
        this.hasUserData = true;
        this.valUserData = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setVisible(boolean)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B visible(boolean value)
    {
        this.hasVisible = true;
        this.valVisible = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.AnchorPane#setBottomAnchor}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B AnchorPane_bottomAnchor(java.lang.Double value)
    {
        this.hasAnchorPane_bottomAnchor = true;
        this.valAnchorPane_bottomAnchor = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.AnchorPane#setLeftAnchor}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B AnchorPane_leftAnchor(java.lang.Double value)
    {
        this.hasAnchorPane_leftAnchor = true;
        this.valAnchorPane_leftAnchor = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.AnchorPane#setRightAnchor}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B AnchorPane_rightAnchor(java.lang.Double value)
    {
        this.hasAnchorPane_rightAnchor = true;
        this.valAnchorPane_rightAnchor = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.AnchorPane#setTopAnchor}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B AnchorPane_topAnchor(java.lang.Double value)
    {
        this.hasAnchorPane_topAnchor = true;
        this.valAnchorPane_topAnchor = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.BorderPane#setAlignment}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B BorderPane_alignment(javafx.geometry.Pos value)
    {
        this.hasBorderPane_alignment = true;
        this.valBorderPane_alignment = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.BorderPane#setMargin}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B BorderPane_margin(javafx.geometry.Insets value)
    {
        this.hasBorderPane_margin = true;
        this.valBorderPane_margin = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.FlowPane#setMargin}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B FlowPane_margin(javafx.geometry.Insets value)
    {
        this.hasFlowPane_margin = true;
        this.valFlowPane_margin = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setColumnIndex}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_columnIndex(java.lang.Integer value)
    {
        this.hasGridPane_columnIndex = true;
        this.valGridPane_columnIndex = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setColumnSpan}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_columnSpan(java.lang.Integer value)
    {
        this.hasGridPane_columnSpan = true;
        this.valGridPane_columnSpan = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setFillHeight}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_fillHeight(java.lang.Boolean value)
    {
        this.hasGridPane_fillHeight = true;
        this.valGridPane_fillHeight = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setFillWidth}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_fillWidth(java.lang.Boolean value)
    {
        this.hasGridPane_fillWidth = true;
        this.valGridPane_fillWidth = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setHalignment}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_halignment(javafx.geometry.HPos value)
    {
        this.hasGridPane_halignment = true;
        this.valGridPane_halignment = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setHgrow}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_hgrow(javafx.scene.layout.Priority value)
    {
        this.hasGridPane_hgrow = true;
        this.valGridPane_hgrow = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setMargin}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_margin(javafx.geometry.Insets value)
    {
        this.hasGridPane_margin = true;
        this.valGridPane_margin = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setRowIndex}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_rowIndex(java.lang.Integer value)
    {
        this.hasGridPane_rowIndex = true;
        this.valGridPane_rowIndex = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setRowSpan}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_rowSpan(java.lang.Integer value)
    {
        this.hasGridPane_rowSpan = true;
        this.valGridPane_rowSpan = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setValignment}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_valignment(javafx.geometry.VPos value)
    {
        this.hasGridPane_valignment = true;
        this.valGridPane_valignment = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setVgrow}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_vgrow(javafx.scene.layout.Priority value)
    {
        this.hasGridPane_vgrow = true;
        this.valGridPane_vgrow = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.HBox#setHgrow}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B HBox_hgrow(javafx.scene.layout.Priority value)
    {
        this.hasHBox_hgrow = true;
        this.valHBox_hgrow = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.HBox#setMargin}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B HBox_margin(javafx.geometry.Insets value)
    {
        this.hasHBox_margin = true;
        this.valHBox_margin = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.control.SplitPane#setResizableWithParent}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B SplitPane_resizableWithParent(java.lang.Boolean value)
    {
        this.hasSplitPane_resizableWithParent = true;
        this.valSplitPane_resizableWithParent = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.StackPane#setAlignment}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B StackPane_alignment(javafx.geometry.Pos value)
    {
        this.hasStackPane_alignment = true;
        this.valStackPane_alignment = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.StackPane#setMargin}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B StackPane_margin(javafx.geometry.Insets value)
    {
        this.hasStackPane_margin = true;
        this.valStackPane_margin = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.TilePane#setAlignment}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B TilePane_alignment(javafx.geometry.Pos value)
    {
        this.hasTilePane_alignment = true;
        this.valTilePane_alignment = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.TilePane#setMargin}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B TilePane_margin(javafx.geometry.Insets value)
    {
        this.hasTilePane_margin = true;
        this.valTilePane_margin = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.VBox#setMargin}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B VBox_margin(javafx.geometry.Insets value)
    {
        this.hasVBox_margin = true;
        this.valVBox_margin = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.VBox#setVgrow}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B VBox_vgrow(javafx.scene.layout.Priority value)
    {
        this.hasVBox_vgrow = true;
        this.valVBox_vgrow = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#blendModeProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBlendMode(javafx.beans.value.ObservableValue<? extends javafx.scene.effect.BlendMode> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1BlendMode = true;
        this.obsrv1BlendMode = source;
        this.bound2BlendMode = false;
        this.obsrv2BlendMode = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#blendModeProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalBlendMode(javafx.beans.property.Property<javafx.scene.effect.BlendMode> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1BlendMode = false;
        this.obsrv1BlendMode = null;
        this.bound2BlendMode = true;
        this.obsrv2BlendMode = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#cacheHintProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindCacheHint(javafx.beans.value.ObservableValue<? extends javafx.scene.CacheHint> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1CacheHint = true;
        this.obsrv1CacheHint = source;
        this.bound2CacheHint = false;
        this.obsrv2CacheHint = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#cacheHintProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalCacheHint(javafx.beans.property.Property<javafx.scene.CacheHint> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1CacheHint = false;
        this.obsrv1CacheHint = null;
        this.bound2CacheHint = true;
        this.obsrv2CacheHint = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#cacheProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindCache(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Cache = true;
        this.obsrv1Cache = source;
        this.bound2Cache = false;
        this.obsrv2Cache = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#cacheProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalCache(javafx.beans.property.Property<Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Cache = false;
        this.obsrv1Cache = null;
        this.bound2Cache = true;
        this.obsrv2Cache = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#clipProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindClip(javafx.beans.value.ObservableValue<? extends javafx.scene.Node> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Clip = true;
        this.obsrv1Clip = source;
        this.bound2Clip = false;
        this.obsrv2Clip = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#clipProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalClip(javafx.beans.property.Property<javafx.scene.Node> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Clip = false;
        this.obsrv1Clip = null;
        this.bound2Clip = true;
        this.obsrv2Clip = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#cursorProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindCursor(javafx.beans.value.ObservableValue<? extends javafx.scene.Cursor> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Cursor = true;
        this.obsrv1Cursor = source;
        this.bound2Cursor = false;
        this.obsrv2Cursor = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#cursorProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalCursor(javafx.beans.property.Property<javafx.scene.Cursor> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Cursor = false;
        this.obsrv1Cursor = null;
        this.bound2Cursor = true;
        this.obsrv2Cursor = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#depthTestProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindDepthTest(javafx.beans.value.ObservableValue<? extends javafx.scene.DepthTest> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1DepthTest = true;
        this.obsrv1DepthTest = source;
        this.bound2DepthTest = false;
        this.obsrv2DepthTest = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#depthTestProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalDepthTest(javafx.beans.property.Property<javafx.scene.DepthTest> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1DepthTest = false;
        this.obsrv1DepthTest = null;
        this.bound2DepthTest = true;
        this.obsrv2DepthTest = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#disableProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindDisable(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Disable = true;
        this.obsrv1Disable = source;
        this.bound2Disable = false;
        this.obsrv2Disable = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#disableProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalDisable(javafx.beans.property.Property<Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Disable = false;
        this.obsrv1Disable = null;
        this.bound2Disable = true;
        this.obsrv2Disable = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#effectProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindEffect(javafx.beans.value.ObservableValue<? extends javafx.scene.effect.Effect> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Effect = true;
        this.obsrv1Effect = source;
        this.bound2Effect = false;
        this.obsrv2Effect = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#effectProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalEffect(javafx.beans.property.Property<javafx.scene.effect.Effect> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Effect = false;
        this.obsrv1Effect = null;
        this.bound2Effect = true;
        this.obsrv2Effect = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#eventDispatcherProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindEventDispatcher(javafx.beans.value.ObservableValue<? extends javafx.event.EventDispatcher> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1EventDispatcher = true;
        this.obsrv1EventDispatcher = source;
        this.bound2EventDispatcher = false;
        this.obsrv2EventDispatcher = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#eventDispatcherProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalEventDispatcher(javafx.beans.property.Property<javafx.event.EventDispatcher> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1EventDispatcher = false;
        this.obsrv1EventDispatcher = null;
        this.bound2EventDispatcher = true;
        this.obsrv2EventDispatcher = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#focusTraversableProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindFocusTraversable(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1FocusTraversable = true;
        this.obsrv1FocusTraversable = source;
        this.bound2FocusTraversable = false;
        this.obsrv2FocusTraversable = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#focusTraversableProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalFocusTraversable(javafx.beans.property.Property<Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1FocusTraversable = false;
        this.obsrv1FocusTraversable = null;
        this.bound2FocusTraversable = true;
        this.obsrv2FocusTraversable = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#idProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindId(javafx.beans.value.ObservableValue<? extends String> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Id = true;
        this.obsrv1Id = source;
        this.bound2Id = false;
        this.obsrv2Id = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#idProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalId(javafx.beans.property.Property<String> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Id = false;
        this.obsrv1Id = null;
        this.bound2Id = true;
        this.obsrv2Id = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#inputMethodRequestsProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindInputMethodRequests(javafx.beans.value.ObservableValue<? extends javafx.scene.input.InputMethodRequests> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1InputMethodRequests = true;
        this.obsrv1InputMethodRequests = source;
        this.bound2InputMethodRequests = false;
        this.obsrv2InputMethodRequests = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#inputMethodRequestsProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalInputMethodRequests(javafx.beans.property.Property<javafx.scene.input.InputMethodRequests> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1InputMethodRequests = false;
        this.obsrv1InputMethodRequests = null;
        this.bound2InputMethodRequests = true;
        this.obsrv2InputMethodRequests = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#layoutXProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindLayoutX(javafx.beans.value.ObservableValue<? extends Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1LayoutX = true;
        this.obsrv1LayoutX = source;
        this.bound2LayoutX = false;
        this.obsrv2LayoutX = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#layoutXProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalLayoutX(javafx.beans.property.Property<Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1LayoutX = false;
        this.obsrv1LayoutX = null;
        this.bound2LayoutX = true;
        this.obsrv2LayoutX = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#layoutYProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindLayoutY(javafx.beans.value.ObservableValue<? extends Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1LayoutY = true;
        this.obsrv1LayoutY = source;
        this.bound2LayoutY = false;
        this.obsrv2LayoutY = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#layoutYProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalLayoutY(javafx.beans.property.Property<Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1LayoutY = false;
        this.obsrv1LayoutY = null;
        this.bound2LayoutY = true;
        this.obsrv2LayoutY = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#managedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindManaged(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Managed = true;
        this.obsrv1Managed = source;
        this.bound2Managed = false;
        this.obsrv2Managed = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#managedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalManaged(javafx.beans.property.Property<Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Managed = false;
        this.obsrv1Managed = null;
        this.bound2Managed = true;
        this.obsrv2Managed = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#mouseTransparentProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindMouseTransparent(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1MouseTransparent = true;
        this.obsrv1MouseTransparent = source;
        this.bound2MouseTransparent = false;
        this.obsrv2MouseTransparent = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#mouseTransparentProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalMouseTransparent(javafx.beans.property.Property<Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1MouseTransparent = false;
        this.obsrv1MouseTransparent = null;
        this.bound2MouseTransparent = true;
        this.obsrv2MouseTransparent = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#nodeOrientationProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindNodeOrientation(javafx.beans.value.ObservableValue<? extends javafx.geometry.NodeOrientation> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1NodeOrientation = true;
        this.obsrv1NodeOrientation = source;
        this.bound2NodeOrientation = false;
        this.obsrv2NodeOrientation = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#nodeOrientationProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalNodeOrientation(javafx.beans.property.Property<javafx.geometry.NodeOrientation> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1NodeOrientation = false;
        this.obsrv1NodeOrientation = null;
        this.bound2NodeOrientation = true;
        this.obsrv2NodeOrientation = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onContextMenuRequestedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnContextMenuRequested(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ContextMenuEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnContextMenuRequested = true;
        this.obsrv1OnContextMenuRequested = source;
        this.bound2OnContextMenuRequested = false;
        this.obsrv2OnContextMenuRequested = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onContextMenuRequestedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnContextMenuRequested(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.ContextMenuEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnContextMenuRequested = false;
        this.obsrv1OnContextMenuRequested = null;
        this.bound2OnContextMenuRequested = true;
        this.obsrv2OnContextMenuRequested = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onDragDetectedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnDragDetected(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnDragDetected = true;
        this.obsrv1OnDragDetected = source;
        this.bound2OnDragDetected = false;
        this.obsrv2OnDragDetected = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onDragDetectedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnDragDetected(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnDragDetected = false;
        this.obsrv1OnDragDetected = null;
        this.bound2OnDragDetected = true;
        this.obsrv2OnDragDetected = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onDragDoneProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnDragDone(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnDragDone = true;
        this.obsrv1OnDragDone = source;
        this.bound2OnDragDone = false;
        this.obsrv2OnDragDone = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onDragDoneProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnDragDone(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnDragDone = false;
        this.obsrv1OnDragDone = null;
        this.bound2OnDragDone = true;
        this.obsrv2OnDragDone = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onDragDroppedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnDragDropped(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnDragDropped = true;
        this.obsrv1OnDragDropped = source;
        this.bound2OnDragDropped = false;
        this.obsrv2OnDragDropped = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onDragDroppedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnDragDropped(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnDragDropped = false;
        this.obsrv1OnDragDropped = null;
        this.bound2OnDragDropped = true;
        this.obsrv2OnDragDropped = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onDragEnteredProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnDragEntered(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnDragEntered = true;
        this.obsrv1OnDragEntered = source;
        this.bound2OnDragEntered = false;
        this.obsrv2OnDragEntered = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onDragEnteredProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnDragEntered(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnDragEntered = false;
        this.obsrv1OnDragEntered = null;
        this.bound2OnDragEntered = true;
        this.obsrv2OnDragEntered = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onDragExitedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnDragExited(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnDragExited = true;
        this.obsrv1OnDragExited = source;
        this.bound2OnDragExited = false;
        this.obsrv2OnDragExited = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onDragExitedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnDragExited(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnDragExited = false;
        this.obsrv1OnDragExited = null;
        this.bound2OnDragExited = true;
        this.obsrv2OnDragExited = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onDragOverProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnDragOver(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnDragOver = true;
        this.obsrv1OnDragOver = source;
        this.bound2OnDragOver = false;
        this.obsrv2OnDragOver = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onDragOverProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnDragOver(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnDragOver = false;
        this.obsrv1OnDragOver = null;
        this.bound2OnDragOver = true;
        this.obsrv2OnDragOver = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onInputMethodTextChangedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnInputMethodTextChanged(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.InputMethodEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnInputMethodTextChanged = true;
        this.obsrv1OnInputMethodTextChanged = source;
        this.bound2OnInputMethodTextChanged = false;
        this.obsrv2OnInputMethodTextChanged = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onInputMethodTextChangedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnInputMethodTextChanged(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.InputMethodEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnInputMethodTextChanged = false;
        this.obsrv1OnInputMethodTextChanged = null;
        this.bound2OnInputMethodTextChanged = true;
        this.obsrv2OnInputMethodTextChanged = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onKeyPressedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnKeyPressed(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.KeyEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnKeyPressed = true;
        this.obsrv1OnKeyPressed = source;
        this.bound2OnKeyPressed = false;
        this.obsrv2OnKeyPressed = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onKeyPressedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnKeyPressed(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.KeyEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnKeyPressed = false;
        this.obsrv1OnKeyPressed = null;
        this.bound2OnKeyPressed = true;
        this.obsrv2OnKeyPressed = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onKeyReleasedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnKeyReleased(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.KeyEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnKeyReleased = true;
        this.obsrv1OnKeyReleased = source;
        this.bound2OnKeyReleased = false;
        this.obsrv2OnKeyReleased = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onKeyReleasedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnKeyReleased(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.KeyEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnKeyReleased = false;
        this.obsrv1OnKeyReleased = null;
        this.bound2OnKeyReleased = true;
        this.obsrv2OnKeyReleased = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onKeyTypedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnKeyTyped(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.KeyEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnKeyTyped = true;
        this.obsrv1OnKeyTyped = source;
        this.bound2OnKeyTyped = false;
        this.obsrv2OnKeyTyped = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onKeyTypedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnKeyTyped(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.KeyEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnKeyTyped = false;
        this.obsrv1OnKeyTyped = null;
        this.bound2OnKeyTyped = true;
        this.obsrv2OnKeyTyped = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseClickedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseClicked(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseClicked = true;
        this.obsrv1OnMouseClicked = source;
        this.bound2OnMouseClicked = false;
        this.obsrv2OnMouseClicked = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseClickedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnMouseClicked(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseClicked = false;
        this.obsrv1OnMouseClicked = null;
        this.bound2OnMouseClicked = true;
        this.obsrv2OnMouseClicked = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseDragEnteredProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseDragEntered(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseDragEntered = true;
        this.obsrv1OnMouseDragEntered = source;
        this.bound2OnMouseDragEntered = false;
        this.obsrv2OnMouseDragEntered = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseDragEnteredProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnMouseDragEntered(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseDragEntered = false;
        this.obsrv1OnMouseDragEntered = null;
        this.bound2OnMouseDragEntered = true;
        this.obsrv2OnMouseDragEntered = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseDragExitedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseDragExited(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseDragExited = true;
        this.obsrv1OnMouseDragExited = source;
        this.bound2OnMouseDragExited = false;
        this.obsrv2OnMouseDragExited = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseDragExitedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnMouseDragExited(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseDragExited = false;
        this.obsrv1OnMouseDragExited = null;
        this.bound2OnMouseDragExited = true;
        this.obsrv2OnMouseDragExited = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseDragOverProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseDragOver(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseDragOver = true;
        this.obsrv1OnMouseDragOver = source;
        this.bound2OnMouseDragOver = false;
        this.obsrv2OnMouseDragOver = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseDragOverProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnMouseDragOver(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseDragOver = false;
        this.obsrv1OnMouseDragOver = null;
        this.bound2OnMouseDragOver = true;
        this.obsrv2OnMouseDragOver = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseDragReleasedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseDragReleased(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseDragReleased = true;
        this.obsrv1OnMouseDragReleased = source;
        this.bound2OnMouseDragReleased = false;
        this.obsrv2OnMouseDragReleased = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseDragReleasedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnMouseDragReleased(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseDragReleased = false;
        this.obsrv1OnMouseDragReleased = null;
        this.bound2OnMouseDragReleased = true;
        this.obsrv2OnMouseDragReleased = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseDraggedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseDragged(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseDragged = true;
        this.obsrv1OnMouseDragged = source;
        this.bound2OnMouseDragged = false;
        this.obsrv2OnMouseDragged = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseDraggedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnMouseDragged(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseDragged = false;
        this.obsrv1OnMouseDragged = null;
        this.bound2OnMouseDragged = true;
        this.obsrv2OnMouseDragged = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseEnteredProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseEntered(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseEntered = true;
        this.obsrv1OnMouseEntered = source;
        this.bound2OnMouseEntered = false;
        this.obsrv2OnMouseEntered = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseEnteredProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnMouseEntered(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseEntered = false;
        this.obsrv1OnMouseEntered = null;
        this.bound2OnMouseEntered = true;
        this.obsrv2OnMouseEntered = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseExitedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseExited(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseExited = true;
        this.obsrv1OnMouseExited = source;
        this.bound2OnMouseExited = false;
        this.obsrv2OnMouseExited = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseExitedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnMouseExited(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseExited = false;
        this.obsrv1OnMouseExited = null;
        this.bound2OnMouseExited = true;
        this.obsrv2OnMouseExited = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseMovedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseMoved(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseMoved = true;
        this.obsrv1OnMouseMoved = source;
        this.bound2OnMouseMoved = false;
        this.obsrv2OnMouseMoved = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseMovedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnMouseMoved(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseMoved = false;
        this.obsrv1OnMouseMoved = null;
        this.bound2OnMouseMoved = true;
        this.obsrv2OnMouseMoved = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMousePressedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMousePressed(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMousePressed = true;
        this.obsrv1OnMousePressed = source;
        this.bound2OnMousePressed = false;
        this.obsrv2OnMousePressed = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMousePressedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnMousePressed(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMousePressed = false;
        this.obsrv1OnMousePressed = null;
        this.bound2OnMousePressed = true;
        this.obsrv2OnMousePressed = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseReleasedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseReleased(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseReleased = true;
        this.obsrv1OnMouseReleased = source;
        this.bound2OnMouseReleased = false;
        this.obsrv2OnMouseReleased = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseReleasedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnMouseReleased(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnMouseReleased = false;
        this.obsrv1OnMouseReleased = null;
        this.bound2OnMouseReleased = true;
        this.obsrv2OnMouseReleased = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onRotateProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnRotate(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.RotateEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnRotate = true;
        this.obsrv1OnRotate = source;
        this.bound2OnRotate = false;
        this.obsrv2OnRotate = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onRotateProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnRotate(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.RotateEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnRotate = false;
        this.obsrv1OnRotate = null;
        this.bound2OnRotate = true;
        this.obsrv2OnRotate = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onRotationFinishedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnRotationFinished(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.RotateEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnRotationFinished = true;
        this.obsrv1OnRotationFinished = source;
        this.bound2OnRotationFinished = false;
        this.obsrv2OnRotationFinished = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onRotationFinishedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnRotationFinished(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.RotateEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnRotationFinished = false;
        this.obsrv1OnRotationFinished = null;
        this.bound2OnRotationFinished = true;
        this.obsrv2OnRotationFinished = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onRotationStartedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnRotationStarted(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.RotateEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnRotationStarted = true;
        this.obsrv1OnRotationStarted = source;
        this.bound2OnRotationStarted = false;
        this.obsrv2OnRotationStarted = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onRotationStartedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnRotationStarted(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.RotateEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnRotationStarted = false;
        this.obsrv1OnRotationStarted = null;
        this.bound2OnRotationStarted = true;
        this.obsrv2OnRotationStarted = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onScrollFinishedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnScrollFinished(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnScrollFinished = true;
        this.obsrv1OnScrollFinished = source;
        this.bound2OnScrollFinished = false;
        this.obsrv2OnScrollFinished = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onScrollFinishedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnScrollFinished(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnScrollFinished = false;
        this.obsrv1OnScrollFinished = null;
        this.bound2OnScrollFinished = true;
        this.obsrv2OnScrollFinished = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onScrollProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnScroll(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnScroll = true;
        this.obsrv1OnScroll = source;
        this.bound2OnScroll = false;
        this.obsrv2OnScroll = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onScrollProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnScroll(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnScroll = false;
        this.obsrv1OnScroll = null;
        this.bound2OnScroll = true;
        this.obsrv2OnScroll = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onScrollStartedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnScrollStarted(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnScrollStarted = true;
        this.obsrv1OnScrollStarted = source;
        this.bound2OnScrollStarted = false;
        this.obsrv2OnScrollStarted = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onScrollStartedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnScrollStarted(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnScrollStarted = false;
        this.obsrv1OnScrollStarted = null;
        this.bound2OnScrollStarted = true;
        this.obsrv2OnScrollStarted = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onSwipeDownProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnSwipeDown(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnSwipeDown = true;
        this.obsrv1OnSwipeDown = source;
        this.bound2OnSwipeDown = false;
        this.obsrv2OnSwipeDown = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onSwipeDownProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnSwipeDown(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnSwipeDown = false;
        this.obsrv1OnSwipeDown = null;
        this.bound2OnSwipeDown = true;
        this.obsrv2OnSwipeDown = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onSwipeLeftProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnSwipeLeft(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnSwipeLeft = true;
        this.obsrv1OnSwipeLeft = source;
        this.bound2OnSwipeLeft = false;
        this.obsrv2OnSwipeLeft = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onSwipeLeftProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnSwipeLeft(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnSwipeLeft = false;
        this.obsrv1OnSwipeLeft = null;
        this.bound2OnSwipeLeft = true;
        this.obsrv2OnSwipeLeft = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onSwipeRightProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnSwipeRight(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnSwipeRight = true;
        this.obsrv1OnSwipeRight = source;
        this.bound2OnSwipeRight = false;
        this.obsrv2OnSwipeRight = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onSwipeRightProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnSwipeRight(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnSwipeRight = false;
        this.obsrv1OnSwipeRight = null;
        this.bound2OnSwipeRight = true;
        this.obsrv2OnSwipeRight = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onSwipeUpProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnSwipeUp(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnSwipeUp = true;
        this.obsrv1OnSwipeUp = source;
        this.bound2OnSwipeUp = false;
        this.obsrv2OnSwipeUp = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onSwipeUpProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnSwipeUp(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnSwipeUp = false;
        this.obsrv1OnSwipeUp = null;
        this.bound2OnSwipeUp = true;
        this.obsrv2OnSwipeUp = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onTouchMovedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnTouchMoved(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnTouchMoved = true;
        this.obsrv1OnTouchMoved = source;
        this.bound2OnTouchMoved = false;
        this.obsrv2OnTouchMoved = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onTouchMovedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnTouchMoved(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnTouchMoved = false;
        this.obsrv1OnTouchMoved = null;
        this.bound2OnTouchMoved = true;
        this.obsrv2OnTouchMoved = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onTouchPressedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnTouchPressed(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnTouchPressed = true;
        this.obsrv1OnTouchPressed = source;
        this.bound2OnTouchPressed = false;
        this.obsrv2OnTouchPressed = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onTouchPressedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnTouchPressed(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnTouchPressed = false;
        this.obsrv1OnTouchPressed = null;
        this.bound2OnTouchPressed = true;
        this.obsrv2OnTouchPressed = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onTouchReleasedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnTouchReleased(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnTouchReleased = true;
        this.obsrv1OnTouchReleased = source;
        this.bound2OnTouchReleased = false;
        this.obsrv2OnTouchReleased = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onTouchReleasedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnTouchReleased(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnTouchReleased = false;
        this.obsrv1OnTouchReleased = null;
        this.bound2OnTouchReleased = true;
        this.obsrv2OnTouchReleased = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onTouchStationaryProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnTouchStationary(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnTouchStationary = true;
        this.obsrv1OnTouchStationary = source;
        this.bound2OnTouchStationary = false;
        this.obsrv2OnTouchStationary = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onTouchStationaryProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnTouchStationary(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnTouchStationary = false;
        this.obsrv1OnTouchStationary = null;
        this.bound2OnTouchStationary = true;
        this.obsrv2OnTouchStationary = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onZoomFinishedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnZoomFinished(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnZoomFinished = true;
        this.obsrv1OnZoomFinished = source;
        this.bound2OnZoomFinished = false;
        this.obsrv2OnZoomFinished = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onZoomFinishedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnZoomFinished(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnZoomFinished = false;
        this.obsrv1OnZoomFinished = null;
        this.bound2OnZoomFinished = true;
        this.obsrv2OnZoomFinished = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onZoomProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnZoom(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnZoom = true;
        this.obsrv1OnZoom = source;
        this.bound2OnZoom = false;
        this.obsrv2OnZoom = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onZoomProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnZoom(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnZoom = false;
        this.obsrv1OnZoom = null;
        this.bound2OnZoom = true;
        this.obsrv2OnZoom = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onZoomStartedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnZoomStarted(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnZoomStarted = true;
        this.obsrv1OnZoomStarted = source;
        this.bound2OnZoomStarted = false;
        this.obsrv2OnZoomStarted = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onZoomStartedProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOnZoomStarted(javafx.beans.property.Property<javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1OnZoomStarted = false;
        this.obsrv1OnZoomStarted = null;
        this.bound2OnZoomStarted = true;
        this.obsrv2OnZoomStarted = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#opacityProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOpacity(javafx.beans.value.ObservableValue<? extends Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Opacity = true;
        this.obsrv1Opacity = source;
        this.bound2Opacity = false;
        this.obsrv2Opacity = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#opacityProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalOpacity(javafx.beans.property.Property<Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Opacity = false;
        this.obsrv1Opacity = null;
        this.bound2Opacity = true;
        this.obsrv2Opacity = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#pickOnBoundsProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindPickOnBounds(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1PickOnBounds = true;
        this.obsrv1PickOnBounds = source;
        this.bound2PickOnBounds = false;
        this.obsrv2PickOnBounds = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#pickOnBoundsProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalPickOnBounds(javafx.beans.property.Property<Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1PickOnBounds = false;
        this.obsrv1PickOnBounds = null;
        this.bound2PickOnBounds = true;
        this.obsrv2PickOnBounds = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#rotateProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindRotate(javafx.beans.value.ObservableValue<? extends Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Rotate = true;
        this.obsrv1Rotate = source;
        this.bound2Rotate = false;
        this.obsrv2Rotate = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#rotateProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalRotate(javafx.beans.property.Property<Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Rotate = false;
        this.obsrv1Rotate = null;
        this.bound2Rotate = true;
        this.obsrv2Rotate = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#rotationAxisProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindRotationAxis(javafx.beans.value.ObservableValue<? extends javafx.geometry.Point3D> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1RotationAxis = true;
        this.obsrv1RotationAxis = source;
        this.bound2RotationAxis = false;
        this.obsrv2RotationAxis = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#rotationAxisProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalRotationAxis(javafx.beans.property.Property<javafx.geometry.Point3D> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1RotationAxis = false;
        this.obsrv1RotationAxis = null;
        this.bound2RotationAxis = true;
        this.obsrv2RotationAxis = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#scaleXProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindScaleX(javafx.beans.value.ObservableValue<? extends Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1ScaleX = true;
        this.obsrv1ScaleX = source;
        this.bound2ScaleX = false;
        this.obsrv2ScaleX = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#scaleXProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalScaleX(javafx.beans.property.Property<Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1ScaleX = false;
        this.obsrv1ScaleX = null;
        this.bound2ScaleX = true;
        this.obsrv2ScaleX = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#scaleYProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindScaleY(javafx.beans.value.ObservableValue<? extends Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1ScaleY = true;
        this.obsrv1ScaleY = source;
        this.bound2ScaleY = false;
        this.obsrv2ScaleY = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#scaleYProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalScaleY(javafx.beans.property.Property<Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1ScaleY = false;
        this.obsrv1ScaleY = null;
        this.bound2ScaleY = true;
        this.obsrv2ScaleY = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#scaleZProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindScaleZ(javafx.beans.value.ObservableValue<? extends Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1ScaleZ = true;
        this.obsrv1ScaleZ = source;
        this.bound2ScaleZ = false;
        this.obsrv2ScaleZ = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#scaleZProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalScaleZ(javafx.beans.property.Property<Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1ScaleZ = false;
        this.obsrv1ScaleZ = null;
        this.bound2ScaleZ = true;
        this.obsrv2ScaleZ = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#styleProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindStyle(javafx.beans.value.ObservableValue<? extends String> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Style = true;
        this.obsrv1Style = source;
        this.bound2Style = false;
        this.obsrv2Style = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#styleProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalStyle(javafx.beans.property.Property<String> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Style = false;
        this.obsrv1Style = null;
        this.bound2Style = true;
        this.obsrv2Style = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#translateXProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindTranslateX(javafx.beans.value.ObservableValue<? extends Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1TranslateX = true;
        this.obsrv1TranslateX = source;
        this.bound2TranslateX = false;
        this.obsrv2TranslateX = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#translateXProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalTranslateX(javafx.beans.property.Property<Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1TranslateX = false;
        this.obsrv1TranslateX = null;
        this.bound2TranslateX = true;
        this.obsrv2TranslateX = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#translateYProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindTranslateY(javafx.beans.value.ObservableValue<? extends Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1TranslateY = true;
        this.obsrv1TranslateY = source;
        this.bound2TranslateY = false;
        this.obsrv2TranslateY = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#translateYProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalTranslateY(javafx.beans.property.Property<Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1TranslateY = false;
        this.obsrv1TranslateY = null;
        this.bound2TranslateY = true;
        this.obsrv2TranslateY = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#translateZProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindTranslateZ(javafx.beans.value.ObservableValue<? extends Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1TranslateZ = true;
        this.obsrv1TranslateZ = source;
        this.bound2TranslateZ = false;
        this.obsrv2TranslateZ = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#translateZProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalTranslateZ(javafx.beans.property.Property<Number> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1TranslateZ = false;
        this.obsrv1TranslateZ = null;
        this.bound2TranslateZ = true;
        this.obsrv2TranslateZ = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#visibleProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindVisible(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Visible = true;
        this.obsrv1Visible = source;
        this.bound2Visible = false;
        this.obsrv2Visible = null;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#visibleProperty}的雙向連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBidirectionalVisible(javafx.beans.property.Property<Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.bound1Visible = false;
        this.obsrv1Visible = null;
        this.bound2Visible = true;
        this.obsrv2Visible = source;
        return (B) this;
    }
}
