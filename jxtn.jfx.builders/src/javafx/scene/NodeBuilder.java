// @formatter:off
/*
 * Unlicensed, generated by javafx.ftl
 */

package javafx.scene;

/**
 * {@link Node}建構器
 *
 * @author JarReflectionDataLoader-1.0.0
 * @version jfxrt.jar
 * @param <Z> 要建構的物件型態(需繼承{@link Node})
 * @param <B> 建構器本身的型態(需繼承{@link NodeBuilder})
 */
@javax.annotation.Generated("Generated by javafx.ftl")
@SuppressWarnings("all")
public class NodeBuilder<Z extends Node, B extends NodeBuilder<Z, B>>
        extends jxtn.jfx.builders.AbstractBuilder<Z, B>
{

    private boolean hasBlendMode;
    private javafx.scene.effect.BlendMode valBlendMode;

    private boolean hasCache;
    private boolean valCache;

    private boolean hasCacheHint;
    private javafx.scene.CacheHint valCacheHint;

    private boolean hasClip;
    private javafx.scene.Node valClip;

    private boolean hasCursor;
    private javafx.scene.Cursor valCursor;

    private boolean hasDepthTest;
    private javafx.scene.DepthTest valDepthTest;

    private boolean hasDisable;
    private boolean valDisable;

    private boolean hasEffect;
    private javafx.scene.effect.Effect valEffect;

    private boolean hasEventDispatcher;
    private javafx.event.EventDispatcher valEventDispatcher;

    private boolean hasFocusTraversable;
    private boolean valFocusTraversable;

    private boolean hasId;
    private java.lang.String valId;

    private boolean hasInputMethodRequests;
    private javafx.scene.input.InputMethodRequests valInputMethodRequests;

    private boolean hasLayoutX;
    private double valLayoutX;

    private boolean hasLayoutY;
    private double valLayoutY;

    private boolean hasManaged;
    private boolean valManaged;

    private boolean hasMouseTransparent;
    private boolean valMouseTransparent;

    private boolean hasNodeOrientation;
    private javafx.geometry.NodeOrientation valNodeOrientation;

    private boolean hasOnContextMenuRequested;
    private javafx.event.EventHandler<? super javafx.scene.input.ContextMenuEvent> valOnContextMenuRequested;

    private boolean hasOnDragDetected;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> valOnDragDetected;

    private boolean hasOnDragDone;
    private javafx.event.EventHandler<? super javafx.scene.input.DragEvent> valOnDragDone;

    private boolean hasOnDragDropped;
    private javafx.event.EventHandler<? super javafx.scene.input.DragEvent> valOnDragDropped;

    private boolean hasOnDragEntered;
    private javafx.event.EventHandler<? super javafx.scene.input.DragEvent> valOnDragEntered;

    private boolean hasOnDragExited;
    private javafx.event.EventHandler<? super javafx.scene.input.DragEvent> valOnDragExited;

    private boolean hasOnDragOver;
    private javafx.event.EventHandler<? super javafx.scene.input.DragEvent> valOnDragOver;

    private boolean hasOnInputMethodTextChanged;
    private javafx.event.EventHandler<? super javafx.scene.input.InputMethodEvent> valOnInputMethodTextChanged;

    private boolean hasOnKeyPressed;
    private javafx.event.EventHandler<? super javafx.scene.input.KeyEvent> valOnKeyPressed;

    private boolean hasOnKeyReleased;
    private javafx.event.EventHandler<? super javafx.scene.input.KeyEvent> valOnKeyReleased;

    private boolean hasOnKeyTyped;
    private javafx.event.EventHandler<? super javafx.scene.input.KeyEvent> valOnKeyTyped;

    private boolean hasOnMouseClicked;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> valOnMouseClicked;

    private boolean hasOnMouseDragEntered;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent> valOnMouseDragEntered;

    private boolean hasOnMouseDragExited;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent> valOnMouseDragExited;

    private boolean hasOnMouseDragOver;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent> valOnMouseDragOver;

    private boolean hasOnMouseDragReleased;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent> valOnMouseDragReleased;

    private boolean hasOnMouseDragged;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> valOnMouseDragged;

    private boolean hasOnMouseEntered;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> valOnMouseEntered;

    private boolean hasOnMouseExited;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> valOnMouseExited;

    private boolean hasOnMouseMoved;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> valOnMouseMoved;

    private boolean hasOnMousePressed;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> valOnMousePressed;

    private boolean hasOnMouseReleased;
    private javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> valOnMouseReleased;

    private boolean hasOnRotate;
    private javafx.event.EventHandler<? super javafx.scene.input.RotateEvent> valOnRotate;

    private boolean hasOnRotationFinished;
    private javafx.event.EventHandler<? super javafx.scene.input.RotateEvent> valOnRotationFinished;

    private boolean hasOnRotationStarted;
    private javafx.event.EventHandler<? super javafx.scene.input.RotateEvent> valOnRotationStarted;

    private boolean hasOnScroll;
    private javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent> valOnScroll;

    private boolean hasOnScrollFinished;
    private javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent> valOnScrollFinished;

    private boolean hasOnScrollStarted;
    private javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent> valOnScrollStarted;

    private boolean hasOnSwipeDown;
    private javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent> valOnSwipeDown;

    private boolean hasOnSwipeLeft;
    private javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent> valOnSwipeLeft;

    private boolean hasOnSwipeRight;
    private javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent> valOnSwipeRight;

    private boolean hasOnSwipeUp;
    private javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent> valOnSwipeUp;

    private boolean hasOnTouchMoved;
    private javafx.event.EventHandler<? super javafx.scene.input.TouchEvent> valOnTouchMoved;

    private boolean hasOnTouchPressed;
    private javafx.event.EventHandler<? super javafx.scene.input.TouchEvent> valOnTouchPressed;

    private boolean hasOnTouchReleased;
    private javafx.event.EventHandler<? super javafx.scene.input.TouchEvent> valOnTouchReleased;

    private boolean hasOnTouchStationary;
    private javafx.event.EventHandler<? super javafx.scene.input.TouchEvent> valOnTouchStationary;

    private boolean hasOnZoom;
    private javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent> valOnZoom;

    private boolean hasOnZoomFinished;
    private javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent> valOnZoomFinished;

    private boolean hasOnZoomStarted;
    private javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent> valOnZoomStarted;

    private boolean hasOpacity;
    private double valOpacity;

    private boolean hasPickOnBounds;
    private boolean valPickOnBounds;

    private boolean hasRotate;
    private double valRotate;

    private boolean hasRotationAxis;
    private javafx.geometry.Point3D valRotationAxis;

    private boolean hasScaleX;
    private double valScaleX;

    private boolean hasScaleY;
    private double valScaleY;

    private boolean hasScaleZ;
    private double valScaleZ;

    private boolean hasStyle;
    private java.lang.String valStyle;

    private boolean hasStyleClass;
    private java.util.Collection<java.lang.String> valStyleClass;

    private boolean hasTransforms;
    private java.util.Collection<javafx.scene.transform.Transform> valTransforms;

    private boolean hasTranslateX;
    private double valTranslateX;

    private boolean hasTranslateY;
    private double valTranslateY;

    private boolean hasTranslateZ;
    private double valTranslateZ;

    private boolean hasUserData;
    private java.lang.Object valUserData;

    private boolean hasVisible;
    private boolean valVisible;

    private boolean hasAnchorPane_bottomAnchor;
    private java.lang.Double valAnchorPane_bottomAnchor;

    private boolean hasAnchorPane_leftAnchor;
    private java.lang.Double valAnchorPane_leftAnchor;

    private boolean hasAnchorPane_rightAnchor;
    private java.lang.Double valAnchorPane_rightAnchor;

    private boolean hasAnchorPane_topAnchor;
    private java.lang.Double valAnchorPane_topAnchor;

    private boolean hasBorderPane_alignment;
    private javafx.geometry.Pos valBorderPane_alignment;

    private boolean hasBorderPane_margin;
    private javafx.geometry.Insets valBorderPane_margin;

    private boolean hasFlowPane_margin;
    private javafx.geometry.Insets valFlowPane_margin;

    private boolean hasGridPane_columnIndex;
    private java.lang.Integer valGridPane_columnIndex;

    private boolean hasGridPane_columnSpan;
    private java.lang.Integer valGridPane_columnSpan;

    private boolean hasGridPane_fillHeight;
    private java.lang.Boolean valGridPane_fillHeight;

    private boolean hasGridPane_fillWidth;
    private java.lang.Boolean valGridPane_fillWidth;

    private boolean hasGridPane_halignment;
    private javafx.geometry.HPos valGridPane_halignment;

    private boolean hasGridPane_hgrow;
    private javafx.scene.layout.Priority valGridPane_hgrow;

    private boolean hasGridPane_margin;
    private javafx.geometry.Insets valGridPane_margin;

    private boolean hasGridPane_rowIndex;
    private java.lang.Integer valGridPane_rowIndex;

    private boolean hasGridPane_rowSpan;
    private java.lang.Integer valGridPane_rowSpan;

    private boolean hasGridPane_valignment;
    private javafx.geometry.VPos valGridPane_valignment;

    private boolean hasGridPane_vgrow;
    private javafx.scene.layout.Priority valGridPane_vgrow;

    private boolean hasHBox_hgrow;
    private javafx.scene.layout.Priority valHBox_hgrow;

    private boolean hasHBox_margin;
    private javafx.geometry.Insets valHBox_margin;

    private boolean hasSplitPane_resizableWithParent;
    private java.lang.Boolean valSplitPane_resizableWithParent;

    private boolean hasStackPane_alignment;
    private javafx.geometry.Pos valStackPane_alignment;

    private boolean hasStackPane_margin;
    private javafx.geometry.Insets valStackPane_margin;

    private boolean hasTilePane_alignment;
    private javafx.geometry.Pos valTilePane_alignment;

    private boolean hasTilePane_margin;
    private javafx.geometry.Insets valTilePane_margin;

    private boolean hasVBox_margin;
    private javafx.geometry.Insets valVBox_margin;

    private boolean hasVBox_vgrow;
    private javafx.scene.layout.Priority valVBox_vgrow;

    private boolean boundBlendMode;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.effect.BlendMode> obsrvBlendMode;

    private boolean boundCacheHint;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.CacheHint> obsrvCacheHint;

    private boolean boundCache;
    private javafx.beans.value.ObservableValue<? extends Boolean> obsrvCache;

    private boolean boundClip;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.Node> obsrvClip;

    private boolean boundCursor;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.Cursor> obsrvCursor;

    private boolean boundDepthTest;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.DepthTest> obsrvDepthTest;

    private boolean boundDisable;
    private javafx.beans.value.ObservableValue<? extends Boolean> obsrvDisable;

    private boolean boundEffect;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.effect.Effect> obsrvEffect;

    private boolean boundEventDispatcher;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventDispatcher> obsrvEventDispatcher;

    private boolean boundFocusTraversable;
    private javafx.beans.value.ObservableValue<? extends Boolean> obsrvFocusTraversable;

    private boolean boundId;
    private javafx.beans.value.ObservableValue<? extends String> obsrvId;

    private boolean boundInputMethodRequests;
    private javafx.beans.value.ObservableValue<? extends javafx.scene.input.InputMethodRequests> obsrvInputMethodRequests;

    private boolean boundLayoutX;
    private javafx.beans.value.ObservableValue<? extends Double> obsrvLayoutX;

    private boolean boundLayoutY;
    private javafx.beans.value.ObservableValue<? extends Double> obsrvLayoutY;

    private boolean boundManaged;
    private javafx.beans.value.ObservableValue<? extends Boolean> obsrvManaged;

    private boolean boundMouseTransparent;
    private javafx.beans.value.ObservableValue<? extends Boolean> obsrvMouseTransparent;

    private boolean boundNodeOrientation;
    private javafx.beans.value.ObservableValue<? extends javafx.geometry.NodeOrientation> obsrvNodeOrientation;

    private boolean boundOnContextMenuRequested;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ContextMenuEvent>> obsrvOnContextMenuRequested;

    private boolean boundOnDragDetected;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrvOnDragDetected;

    private boolean boundOnDragDone;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> obsrvOnDragDone;

    private boolean boundOnDragDropped;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> obsrvOnDragDropped;

    private boolean boundOnDragEntered;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> obsrvOnDragEntered;

    private boolean boundOnDragExited;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> obsrvOnDragExited;

    private boolean boundOnDragOver;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> obsrvOnDragOver;

    private boolean boundOnInputMethodTextChanged;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.InputMethodEvent>> obsrvOnInputMethodTextChanged;

    private boolean boundOnKeyPressed;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.KeyEvent>> obsrvOnKeyPressed;

    private boolean boundOnKeyReleased;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.KeyEvent>> obsrvOnKeyReleased;

    private boolean boundOnKeyTyped;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.KeyEvent>> obsrvOnKeyTyped;

    private boolean boundOnMouseClicked;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrvOnMouseClicked;

    private boolean boundOnMouseDragEntered;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> obsrvOnMouseDragEntered;

    private boolean boundOnMouseDragExited;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> obsrvOnMouseDragExited;

    private boolean boundOnMouseDragOver;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> obsrvOnMouseDragOver;

    private boolean boundOnMouseDragReleased;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> obsrvOnMouseDragReleased;

    private boolean boundOnMouseDragged;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrvOnMouseDragged;

    private boolean boundOnMouseEntered;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrvOnMouseEntered;

    private boolean boundOnMouseExited;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrvOnMouseExited;

    private boolean boundOnMouseMoved;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrvOnMouseMoved;

    private boolean boundOnMousePressed;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrvOnMousePressed;

    private boolean boundOnMouseReleased;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> obsrvOnMouseReleased;

    private boolean boundOnRotate;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.RotateEvent>> obsrvOnRotate;

    private boolean boundOnRotationFinished;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.RotateEvent>> obsrvOnRotationFinished;

    private boolean boundOnRotationStarted;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.RotateEvent>> obsrvOnRotationStarted;

    private boolean boundOnScrollFinished;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent>> obsrvOnScrollFinished;

    private boolean boundOnScroll;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent>> obsrvOnScroll;

    private boolean boundOnScrollStarted;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent>> obsrvOnScrollStarted;

    private boolean boundOnSwipeDown;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> obsrvOnSwipeDown;

    private boolean boundOnSwipeLeft;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> obsrvOnSwipeLeft;

    private boolean boundOnSwipeRight;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> obsrvOnSwipeRight;

    private boolean boundOnSwipeUp;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> obsrvOnSwipeUp;

    private boolean boundOnTouchMoved;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> obsrvOnTouchMoved;

    private boolean boundOnTouchPressed;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> obsrvOnTouchPressed;

    private boolean boundOnTouchReleased;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> obsrvOnTouchReleased;

    private boolean boundOnTouchStationary;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> obsrvOnTouchStationary;

    private boolean boundOnZoomFinished;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent>> obsrvOnZoomFinished;

    private boolean boundOnZoom;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent>> obsrvOnZoom;

    private boolean boundOnZoomStarted;
    private javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent>> obsrvOnZoomStarted;

    private boolean boundOpacity;
    private javafx.beans.value.ObservableValue<? extends Double> obsrvOpacity;

    private boolean boundPickOnBounds;
    private javafx.beans.value.ObservableValue<? extends Boolean> obsrvPickOnBounds;

    private boolean boundRotate;
    private javafx.beans.value.ObservableValue<? extends Double> obsrvRotate;

    private boolean boundRotationAxis;
    private javafx.beans.value.ObservableValue<? extends javafx.geometry.Point3D> obsrvRotationAxis;

    private boolean boundScaleX;
    private javafx.beans.value.ObservableValue<? extends Double> obsrvScaleX;

    private boolean boundScaleY;
    private javafx.beans.value.ObservableValue<? extends Double> obsrvScaleY;

    private boolean boundScaleZ;
    private javafx.beans.value.ObservableValue<? extends Double> obsrvScaleZ;

    private boolean boundStyle;
    private javafx.beans.value.ObservableValue<? extends String> obsrvStyle;

    private boolean boundTranslateX;
    private javafx.beans.value.ObservableValue<? extends Double> obsrvTranslateX;

    private boolean boundTranslateY;
    private javafx.beans.value.ObservableValue<? extends Double> obsrvTranslateY;

    private boolean boundTranslateZ;
    private javafx.beans.value.ObservableValue<? extends Double> obsrvTranslateZ;

    private boolean boundVisible;
    private javafx.beans.value.ObservableValue<? extends Boolean> obsrvVisible;

    @Override
    public void applyTo(Z instance)
    {
        super.applyTo(instance);
        if (this.hasBlendMode)
            instance.setBlendMode(this.valBlendMode);
        if (this.hasCache)
            instance.setCache(this.valCache);
        if (this.hasCacheHint)
            instance.setCacheHint(this.valCacheHint);
        if (this.hasClip)
            instance.setClip(this.valClip);
        if (this.hasCursor)
            instance.setCursor(this.valCursor);
        if (this.hasDepthTest)
            instance.setDepthTest(this.valDepthTest);
        if (this.hasDisable)
            instance.setDisable(this.valDisable);
        if (this.hasEffect)
            instance.setEffect(this.valEffect);
        if (this.hasEventDispatcher)
            instance.setEventDispatcher(this.valEventDispatcher);
        if (this.hasFocusTraversable)
            instance.setFocusTraversable(this.valFocusTraversable);
        if (this.hasId)
            instance.setId(this.valId);
        if (this.hasInputMethodRequests)
            instance.setInputMethodRequests(this.valInputMethodRequests);
        if (this.hasLayoutX)
            instance.setLayoutX(this.valLayoutX);
        if (this.hasLayoutY)
            instance.setLayoutY(this.valLayoutY);
        if (this.hasManaged)
            instance.setManaged(this.valManaged);
        if (this.hasMouseTransparent)
            instance.setMouseTransparent(this.valMouseTransparent);
        if (this.hasNodeOrientation)
            instance.setNodeOrientation(this.valNodeOrientation);
        if (this.hasOnContextMenuRequested)
            instance.setOnContextMenuRequested(this.valOnContextMenuRequested);
        if (this.hasOnDragDetected)
            instance.setOnDragDetected(this.valOnDragDetected);
        if (this.hasOnDragDone)
            instance.setOnDragDone(this.valOnDragDone);
        if (this.hasOnDragDropped)
            instance.setOnDragDropped(this.valOnDragDropped);
        if (this.hasOnDragEntered)
            instance.setOnDragEntered(this.valOnDragEntered);
        if (this.hasOnDragExited)
            instance.setOnDragExited(this.valOnDragExited);
        if (this.hasOnDragOver)
            instance.setOnDragOver(this.valOnDragOver);
        if (this.hasOnInputMethodTextChanged)
            instance.setOnInputMethodTextChanged(this.valOnInputMethodTextChanged);
        if (this.hasOnKeyPressed)
            instance.setOnKeyPressed(this.valOnKeyPressed);
        if (this.hasOnKeyReleased)
            instance.setOnKeyReleased(this.valOnKeyReleased);
        if (this.hasOnKeyTyped)
            instance.setOnKeyTyped(this.valOnKeyTyped);
        if (this.hasOnMouseClicked)
            instance.setOnMouseClicked(this.valOnMouseClicked);
        if (this.hasOnMouseDragEntered)
            instance.setOnMouseDragEntered(this.valOnMouseDragEntered);
        if (this.hasOnMouseDragExited)
            instance.setOnMouseDragExited(this.valOnMouseDragExited);
        if (this.hasOnMouseDragOver)
            instance.setOnMouseDragOver(this.valOnMouseDragOver);
        if (this.hasOnMouseDragReleased)
            instance.setOnMouseDragReleased(this.valOnMouseDragReleased);
        if (this.hasOnMouseDragged)
            instance.setOnMouseDragged(this.valOnMouseDragged);
        if (this.hasOnMouseEntered)
            instance.setOnMouseEntered(this.valOnMouseEntered);
        if (this.hasOnMouseExited)
            instance.setOnMouseExited(this.valOnMouseExited);
        if (this.hasOnMouseMoved)
            instance.setOnMouseMoved(this.valOnMouseMoved);
        if (this.hasOnMousePressed)
            instance.setOnMousePressed(this.valOnMousePressed);
        if (this.hasOnMouseReleased)
            instance.setOnMouseReleased(this.valOnMouseReleased);
        if (this.hasOnRotate)
            instance.setOnRotate(this.valOnRotate);
        if (this.hasOnRotationFinished)
            instance.setOnRotationFinished(this.valOnRotationFinished);
        if (this.hasOnRotationStarted)
            instance.setOnRotationStarted(this.valOnRotationStarted);
        if (this.hasOnScroll)
            instance.setOnScroll(this.valOnScroll);
        if (this.hasOnScrollFinished)
            instance.setOnScrollFinished(this.valOnScrollFinished);
        if (this.hasOnScrollStarted)
            instance.setOnScrollStarted(this.valOnScrollStarted);
        if (this.hasOnSwipeDown)
            instance.setOnSwipeDown(this.valOnSwipeDown);
        if (this.hasOnSwipeLeft)
            instance.setOnSwipeLeft(this.valOnSwipeLeft);
        if (this.hasOnSwipeRight)
            instance.setOnSwipeRight(this.valOnSwipeRight);
        if (this.hasOnSwipeUp)
            instance.setOnSwipeUp(this.valOnSwipeUp);
        if (this.hasOnTouchMoved)
            instance.setOnTouchMoved(this.valOnTouchMoved);
        if (this.hasOnTouchPressed)
            instance.setOnTouchPressed(this.valOnTouchPressed);
        if (this.hasOnTouchReleased)
            instance.setOnTouchReleased(this.valOnTouchReleased);
        if (this.hasOnTouchStationary)
            instance.setOnTouchStationary(this.valOnTouchStationary);
        if (this.hasOnZoom)
            instance.setOnZoom(this.valOnZoom);
        if (this.hasOnZoomFinished)
            instance.setOnZoomFinished(this.valOnZoomFinished);
        if (this.hasOnZoomStarted)
            instance.setOnZoomStarted(this.valOnZoomStarted);
        if (this.hasOpacity)
            instance.setOpacity(this.valOpacity);
        if (this.hasPickOnBounds)
            instance.setPickOnBounds(this.valPickOnBounds);
        if (this.hasRotate)
            instance.setRotate(this.valRotate);
        if (this.hasRotationAxis)
            instance.setRotationAxis(this.valRotationAxis);
        if (this.hasScaleX)
            instance.setScaleX(this.valScaleX);
        if (this.hasScaleY)
            instance.setScaleY(this.valScaleY);
        if (this.hasScaleZ)
            instance.setScaleZ(this.valScaleZ);
        if (this.hasStyle)
            instance.setStyle(this.valStyle);
        if (this.hasStyleClass)
            instance.getStyleClass().setAll(this.valStyleClass);
        if (this.hasTransforms)
            instance.getTransforms().setAll(this.valTransforms);
        if (this.hasTranslateX)
            instance.setTranslateX(this.valTranslateX);
        if (this.hasTranslateY)
            instance.setTranslateY(this.valTranslateY);
        if (this.hasTranslateZ)
            instance.setTranslateZ(this.valTranslateZ);
        if (this.hasUserData)
            instance.setUserData(this.valUserData);
        if (this.hasVisible)
            instance.setVisible(this.valVisible);
        if (this.hasAnchorPane_bottomAnchor)
            javafx.scene.layout.AnchorPane.setBottomAnchor(instance, this.valAnchorPane_bottomAnchor);
        if (this.hasAnchorPane_leftAnchor)
            javafx.scene.layout.AnchorPane.setLeftAnchor(instance, this.valAnchorPane_leftAnchor);
        if (this.hasAnchorPane_rightAnchor)
            javafx.scene.layout.AnchorPane.setRightAnchor(instance, this.valAnchorPane_rightAnchor);
        if (this.hasAnchorPane_topAnchor)
            javafx.scene.layout.AnchorPane.setTopAnchor(instance, this.valAnchorPane_topAnchor);
        if (this.hasBorderPane_alignment)
            javafx.scene.layout.BorderPane.setAlignment(instance, this.valBorderPane_alignment);
        if (this.hasBorderPane_margin)
            javafx.scene.layout.BorderPane.setMargin(instance, this.valBorderPane_margin);
        if (this.hasFlowPane_margin)
            javafx.scene.layout.FlowPane.setMargin(instance, this.valFlowPane_margin);
        if (this.hasGridPane_columnIndex)
            javafx.scene.layout.GridPane.setColumnIndex(instance, this.valGridPane_columnIndex);
        if (this.hasGridPane_columnSpan)
            javafx.scene.layout.GridPane.setColumnSpan(instance, this.valGridPane_columnSpan);
        if (this.hasGridPane_fillHeight)
            javafx.scene.layout.GridPane.setFillHeight(instance, this.valGridPane_fillHeight);
        if (this.hasGridPane_fillWidth)
            javafx.scene.layout.GridPane.setFillWidth(instance, this.valGridPane_fillWidth);
        if (this.hasGridPane_halignment)
            javafx.scene.layout.GridPane.setHalignment(instance, this.valGridPane_halignment);
        if (this.hasGridPane_hgrow)
            javafx.scene.layout.GridPane.setHgrow(instance, this.valGridPane_hgrow);
        if (this.hasGridPane_margin)
            javafx.scene.layout.GridPane.setMargin(instance, this.valGridPane_margin);
        if (this.hasGridPane_rowIndex)
            javafx.scene.layout.GridPane.setRowIndex(instance, this.valGridPane_rowIndex);
        if (this.hasGridPane_rowSpan)
            javafx.scene.layout.GridPane.setRowSpan(instance, this.valGridPane_rowSpan);
        if (this.hasGridPane_valignment)
            javafx.scene.layout.GridPane.setValignment(instance, this.valGridPane_valignment);
        if (this.hasGridPane_vgrow)
            javafx.scene.layout.GridPane.setVgrow(instance, this.valGridPane_vgrow);
        if (this.hasHBox_hgrow)
            javafx.scene.layout.HBox.setHgrow(instance, this.valHBox_hgrow);
        if (this.hasHBox_margin)
            javafx.scene.layout.HBox.setMargin(instance, this.valHBox_margin);
        if (this.hasSplitPane_resizableWithParent)
            javafx.scene.control.SplitPane.setResizableWithParent(instance, this.valSplitPane_resizableWithParent);
        if (this.hasStackPane_alignment)
            javafx.scene.layout.StackPane.setAlignment(instance, this.valStackPane_alignment);
        if (this.hasStackPane_margin)
            javafx.scene.layout.StackPane.setMargin(instance, this.valStackPane_margin);
        if (this.hasTilePane_alignment)
            javafx.scene.layout.TilePane.setAlignment(instance, this.valTilePane_alignment);
        if (this.hasTilePane_margin)
            javafx.scene.layout.TilePane.setMargin(instance, this.valTilePane_margin);
        if (this.hasVBox_margin)
            javafx.scene.layout.VBox.setMargin(instance, this.valVBox_margin);
        if (this.hasVBox_vgrow)
            javafx.scene.layout.VBox.setVgrow(instance, this.valVBox_vgrow);
        if (this.boundBlendMode)
            instance.blendModeProperty().bind(this.obsrvBlendMode);
        if (this.boundCacheHint)
            instance.cacheHintProperty().bind(this.obsrvCacheHint);
        if (this.boundCache)
            instance.cacheProperty().bind(this.obsrvCache);
        if (this.boundClip)
            instance.clipProperty().bind(this.obsrvClip);
        if (this.boundCursor)
            instance.cursorProperty().bind(this.obsrvCursor);
        if (this.boundDepthTest)
            instance.depthTestProperty().bind(this.obsrvDepthTest);
        if (this.boundDisable)
            instance.disableProperty().bind(this.obsrvDisable);
        if (this.boundEffect)
            instance.effectProperty().bind(this.obsrvEffect);
        if (this.boundEventDispatcher)
            instance.eventDispatcherProperty().bind(this.obsrvEventDispatcher);
        if (this.boundFocusTraversable)
            instance.focusTraversableProperty().bind(this.obsrvFocusTraversable);
        if (this.boundId)
            instance.idProperty().bind(this.obsrvId);
        if (this.boundInputMethodRequests)
            instance.inputMethodRequestsProperty().bind(this.obsrvInputMethodRequests);
        if (this.boundLayoutX)
            instance.layoutXProperty().bind(this.obsrvLayoutX);
        if (this.boundLayoutY)
            instance.layoutYProperty().bind(this.obsrvLayoutY);
        if (this.boundManaged)
            instance.managedProperty().bind(this.obsrvManaged);
        if (this.boundMouseTransparent)
            instance.mouseTransparentProperty().bind(this.obsrvMouseTransparent);
        if (this.boundNodeOrientation)
            instance.nodeOrientationProperty().bind(this.obsrvNodeOrientation);
        if (this.boundOnContextMenuRequested)
            instance.onContextMenuRequestedProperty().bind(this.obsrvOnContextMenuRequested);
        if (this.boundOnDragDetected)
            instance.onDragDetectedProperty().bind(this.obsrvOnDragDetected);
        if (this.boundOnDragDone)
            instance.onDragDoneProperty().bind(this.obsrvOnDragDone);
        if (this.boundOnDragDropped)
            instance.onDragDroppedProperty().bind(this.obsrvOnDragDropped);
        if (this.boundOnDragEntered)
            instance.onDragEnteredProperty().bind(this.obsrvOnDragEntered);
        if (this.boundOnDragExited)
            instance.onDragExitedProperty().bind(this.obsrvOnDragExited);
        if (this.boundOnDragOver)
            instance.onDragOverProperty().bind(this.obsrvOnDragOver);
        if (this.boundOnInputMethodTextChanged)
            instance.onInputMethodTextChangedProperty().bind(this.obsrvOnInputMethodTextChanged);
        if (this.boundOnKeyPressed)
            instance.onKeyPressedProperty().bind(this.obsrvOnKeyPressed);
        if (this.boundOnKeyReleased)
            instance.onKeyReleasedProperty().bind(this.obsrvOnKeyReleased);
        if (this.boundOnKeyTyped)
            instance.onKeyTypedProperty().bind(this.obsrvOnKeyTyped);
        if (this.boundOnMouseClicked)
            instance.onMouseClickedProperty().bind(this.obsrvOnMouseClicked);
        if (this.boundOnMouseDragEntered)
            instance.onMouseDragEnteredProperty().bind(this.obsrvOnMouseDragEntered);
        if (this.boundOnMouseDragExited)
            instance.onMouseDragExitedProperty().bind(this.obsrvOnMouseDragExited);
        if (this.boundOnMouseDragOver)
            instance.onMouseDragOverProperty().bind(this.obsrvOnMouseDragOver);
        if (this.boundOnMouseDragReleased)
            instance.onMouseDragReleasedProperty().bind(this.obsrvOnMouseDragReleased);
        if (this.boundOnMouseDragged)
            instance.onMouseDraggedProperty().bind(this.obsrvOnMouseDragged);
        if (this.boundOnMouseEntered)
            instance.onMouseEnteredProperty().bind(this.obsrvOnMouseEntered);
        if (this.boundOnMouseExited)
            instance.onMouseExitedProperty().bind(this.obsrvOnMouseExited);
        if (this.boundOnMouseMoved)
            instance.onMouseMovedProperty().bind(this.obsrvOnMouseMoved);
        if (this.boundOnMousePressed)
            instance.onMousePressedProperty().bind(this.obsrvOnMousePressed);
        if (this.boundOnMouseReleased)
            instance.onMouseReleasedProperty().bind(this.obsrvOnMouseReleased);
        if (this.boundOnRotate)
            instance.onRotateProperty().bind(this.obsrvOnRotate);
        if (this.boundOnRotationFinished)
            instance.onRotationFinishedProperty().bind(this.obsrvOnRotationFinished);
        if (this.boundOnRotationStarted)
            instance.onRotationStartedProperty().bind(this.obsrvOnRotationStarted);
        if (this.boundOnScrollFinished)
            instance.onScrollFinishedProperty().bind(this.obsrvOnScrollFinished);
        if (this.boundOnScroll)
            instance.onScrollProperty().bind(this.obsrvOnScroll);
        if (this.boundOnScrollStarted)
            instance.onScrollStartedProperty().bind(this.obsrvOnScrollStarted);
        if (this.boundOnSwipeDown)
            instance.onSwipeDownProperty().bind(this.obsrvOnSwipeDown);
        if (this.boundOnSwipeLeft)
            instance.onSwipeLeftProperty().bind(this.obsrvOnSwipeLeft);
        if (this.boundOnSwipeRight)
            instance.onSwipeRightProperty().bind(this.obsrvOnSwipeRight);
        if (this.boundOnSwipeUp)
            instance.onSwipeUpProperty().bind(this.obsrvOnSwipeUp);
        if (this.boundOnTouchMoved)
            instance.onTouchMovedProperty().bind(this.obsrvOnTouchMoved);
        if (this.boundOnTouchPressed)
            instance.onTouchPressedProperty().bind(this.obsrvOnTouchPressed);
        if (this.boundOnTouchReleased)
            instance.onTouchReleasedProperty().bind(this.obsrvOnTouchReleased);
        if (this.boundOnTouchStationary)
            instance.onTouchStationaryProperty().bind(this.obsrvOnTouchStationary);
        if (this.boundOnZoomFinished)
            instance.onZoomFinishedProperty().bind(this.obsrvOnZoomFinished);
        if (this.boundOnZoom)
            instance.onZoomProperty().bind(this.obsrvOnZoom);
        if (this.boundOnZoomStarted)
            instance.onZoomStartedProperty().bind(this.obsrvOnZoomStarted);
        if (this.boundOpacity)
            instance.opacityProperty().bind(this.obsrvOpacity);
        if (this.boundPickOnBounds)
            instance.pickOnBoundsProperty().bind(this.obsrvPickOnBounds);
        if (this.boundRotate)
            instance.rotateProperty().bind(this.obsrvRotate);
        if (this.boundRotationAxis)
            instance.rotationAxisProperty().bind(this.obsrvRotationAxis);
        if (this.boundScaleX)
            instance.scaleXProperty().bind(this.obsrvScaleX);
        if (this.boundScaleY)
            instance.scaleYProperty().bind(this.obsrvScaleY);
        if (this.boundScaleZ)
            instance.scaleZProperty().bind(this.obsrvScaleZ);
        if (this.boundStyle)
            instance.styleProperty().bind(this.obsrvStyle);
        if (this.boundTranslateX)
            instance.translateXProperty().bind(this.obsrvTranslateX);
        if (this.boundTranslateY)
            instance.translateYProperty().bind(this.obsrvTranslateY);
        if (this.boundTranslateZ)
            instance.translateZProperty().bind(this.obsrvTranslateZ);
        if (this.boundVisible)
            instance.visibleProperty().bind(this.obsrvVisible);
    }

    /**
     * 設定屬性{@link Node#setBlendMode(javafx.scene.effect.BlendMode)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B blendMode(javafx.scene.effect.BlendMode value)
    {
        this.hasBlendMode = true;
        this.valBlendMode = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setCache(boolean)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B cache(boolean value)
    {
        this.hasCache = true;
        this.valCache = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setCacheHint(javafx.scene.CacheHint)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B cacheHint(javafx.scene.CacheHint value)
    {
        this.hasCacheHint = true;
        this.valCacheHint = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setClip(javafx.scene.Node)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B clip(javafx.scene.Node value)
    {
        this.hasClip = true;
        this.valClip = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setCursor(javafx.scene.Cursor)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B cursor(javafx.scene.Cursor value)
    {
        this.hasCursor = true;
        this.valCursor = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setDepthTest(javafx.scene.DepthTest)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B depthTest(javafx.scene.DepthTest value)
    {
        this.hasDepthTest = true;
        this.valDepthTest = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setDisable(boolean)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B disable(boolean value)
    {
        this.hasDisable = true;
        this.valDisable = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setEffect(javafx.scene.effect.Effect)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B effect(javafx.scene.effect.Effect value)
    {
        this.hasEffect = true;
        this.valEffect = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setEventDispatcher(javafx.event.EventDispatcher)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B eventDispatcher(javafx.event.EventDispatcher value)
    {
        this.hasEventDispatcher = true;
        this.valEventDispatcher = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setFocusTraversable(boolean)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B focusTraversable(boolean value)
    {
        this.hasFocusTraversable = true;
        this.valFocusTraversable = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setId(java.lang.String)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B id(java.lang.String value)
    {
        this.hasId = true;
        this.valId = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setInputMethodRequests(javafx.scene.input.InputMethodRequests)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B inputMethodRequests(javafx.scene.input.InputMethodRequests value)
    {
        this.hasInputMethodRequests = true;
        this.valInputMethodRequests = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setLayoutX(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B layoutX(double value)
    {
        this.hasLayoutX = true;
        this.valLayoutX = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setLayoutY(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B layoutY(double value)
    {
        this.hasLayoutY = true;
        this.valLayoutY = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setManaged(boolean)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B managed(boolean value)
    {
        this.hasManaged = true;
        this.valManaged = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setMouseTransparent(boolean)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B mouseTransparent(boolean value)
    {
        this.hasMouseTransparent = true;
        this.valMouseTransparent = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setNodeOrientation(javafx.geometry.NodeOrientation)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B nodeOrientation(javafx.geometry.NodeOrientation value)
    {
        this.hasNodeOrientation = true;
        this.valNodeOrientation = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnContextMenuRequested(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onContextMenuRequested(javafx.event.EventHandler<? super javafx.scene.input.ContextMenuEvent> value)
    {
        this.hasOnContextMenuRequested = true;
        this.valOnContextMenuRequested = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnDragDetected(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onDragDetected(javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> value)
    {
        this.hasOnDragDetected = true;
        this.valOnDragDetected = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnDragDone(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onDragDone(javafx.event.EventHandler<? super javafx.scene.input.DragEvent> value)
    {
        this.hasOnDragDone = true;
        this.valOnDragDone = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnDragDropped(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onDragDropped(javafx.event.EventHandler<? super javafx.scene.input.DragEvent> value)
    {
        this.hasOnDragDropped = true;
        this.valOnDragDropped = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnDragEntered(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onDragEntered(javafx.event.EventHandler<? super javafx.scene.input.DragEvent> value)
    {
        this.hasOnDragEntered = true;
        this.valOnDragEntered = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnDragExited(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onDragExited(javafx.event.EventHandler<? super javafx.scene.input.DragEvent> value)
    {
        this.hasOnDragExited = true;
        this.valOnDragExited = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnDragOver(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onDragOver(javafx.event.EventHandler<? super javafx.scene.input.DragEvent> value)
    {
        this.hasOnDragOver = true;
        this.valOnDragOver = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnInputMethodTextChanged(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onInputMethodTextChanged(javafx.event.EventHandler<? super javafx.scene.input.InputMethodEvent> value)
    {
        this.hasOnInputMethodTextChanged = true;
        this.valOnInputMethodTextChanged = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnKeyPressed(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onKeyPressed(javafx.event.EventHandler<? super javafx.scene.input.KeyEvent> value)
    {
        this.hasOnKeyPressed = true;
        this.valOnKeyPressed = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnKeyReleased(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onKeyReleased(javafx.event.EventHandler<? super javafx.scene.input.KeyEvent> value)
    {
        this.hasOnKeyReleased = true;
        this.valOnKeyReleased = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnKeyTyped(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onKeyTyped(javafx.event.EventHandler<? super javafx.scene.input.KeyEvent> value)
    {
        this.hasOnKeyTyped = true;
        this.valOnKeyTyped = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseClicked(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseClicked(javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> value)
    {
        this.hasOnMouseClicked = true;
        this.valOnMouseClicked = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseDragEntered(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseDragEntered(javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent> value)
    {
        this.hasOnMouseDragEntered = true;
        this.valOnMouseDragEntered = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseDragExited(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseDragExited(javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent> value)
    {
        this.hasOnMouseDragExited = true;
        this.valOnMouseDragExited = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseDragOver(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseDragOver(javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent> value)
    {
        this.hasOnMouseDragOver = true;
        this.valOnMouseDragOver = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseDragReleased(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseDragReleased(javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent> value)
    {
        this.hasOnMouseDragReleased = true;
        this.valOnMouseDragReleased = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseDragged(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseDragged(javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> value)
    {
        this.hasOnMouseDragged = true;
        this.valOnMouseDragged = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseEntered(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseEntered(javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> value)
    {
        this.hasOnMouseEntered = true;
        this.valOnMouseEntered = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseExited(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseExited(javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> value)
    {
        this.hasOnMouseExited = true;
        this.valOnMouseExited = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseMoved(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseMoved(javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> value)
    {
        this.hasOnMouseMoved = true;
        this.valOnMouseMoved = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMousePressed(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMousePressed(javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> value)
    {
        this.hasOnMousePressed = true;
        this.valOnMousePressed = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnMouseReleased(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onMouseReleased(javafx.event.EventHandler<? super javafx.scene.input.MouseEvent> value)
    {
        this.hasOnMouseReleased = true;
        this.valOnMouseReleased = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnRotate(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onRotate(javafx.event.EventHandler<? super javafx.scene.input.RotateEvent> value)
    {
        this.hasOnRotate = true;
        this.valOnRotate = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnRotationFinished(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onRotationFinished(javafx.event.EventHandler<? super javafx.scene.input.RotateEvent> value)
    {
        this.hasOnRotationFinished = true;
        this.valOnRotationFinished = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnRotationStarted(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onRotationStarted(javafx.event.EventHandler<? super javafx.scene.input.RotateEvent> value)
    {
        this.hasOnRotationStarted = true;
        this.valOnRotationStarted = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnScroll(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onScroll(javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent> value)
    {
        this.hasOnScroll = true;
        this.valOnScroll = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnScrollFinished(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onScrollFinished(javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent> value)
    {
        this.hasOnScrollFinished = true;
        this.valOnScrollFinished = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnScrollStarted(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onScrollStarted(javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent> value)
    {
        this.hasOnScrollStarted = true;
        this.valOnScrollStarted = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnSwipeDown(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onSwipeDown(javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent> value)
    {
        this.hasOnSwipeDown = true;
        this.valOnSwipeDown = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnSwipeLeft(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onSwipeLeft(javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent> value)
    {
        this.hasOnSwipeLeft = true;
        this.valOnSwipeLeft = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnSwipeRight(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onSwipeRight(javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent> value)
    {
        this.hasOnSwipeRight = true;
        this.valOnSwipeRight = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnSwipeUp(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onSwipeUp(javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent> value)
    {
        this.hasOnSwipeUp = true;
        this.valOnSwipeUp = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnTouchMoved(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onTouchMoved(javafx.event.EventHandler<? super javafx.scene.input.TouchEvent> value)
    {
        this.hasOnTouchMoved = true;
        this.valOnTouchMoved = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnTouchPressed(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onTouchPressed(javafx.event.EventHandler<? super javafx.scene.input.TouchEvent> value)
    {
        this.hasOnTouchPressed = true;
        this.valOnTouchPressed = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnTouchReleased(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onTouchReleased(javafx.event.EventHandler<? super javafx.scene.input.TouchEvent> value)
    {
        this.hasOnTouchReleased = true;
        this.valOnTouchReleased = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnTouchStationary(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onTouchStationary(javafx.event.EventHandler<? super javafx.scene.input.TouchEvent> value)
    {
        this.hasOnTouchStationary = true;
        this.valOnTouchStationary = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnZoom(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onZoom(javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent> value)
    {
        this.hasOnZoom = true;
        this.valOnZoom = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnZoomFinished(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onZoomFinished(javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent> value)
    {
        this.hasOnZoomFinished = true;
        this.valOnZoomFinished = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOnZoomStarted(javafx.event.EventHandler)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B onZoomStarted(javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent> value)
    {
        this.hasOnZoomStarted = true;
        this.valOnZoomStarted = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setOpacity(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B opacity(double value)
    {
        this.hasOpacity = true;
        this.valOpacity = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setPickOnBounds(boolean)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B pickOnBounds(boolean value)
    {
        this.hasPickOnBounds = true;
        this.valPickOnBounds = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setRotate(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B rotate(double value)
    {
        this.hasRotate = true;
        this.valRotate = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setRotationAxis(javafx.geometry.Point3D)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B rotationAxis(javafx.geometry.Point3D value)
    {
        this.hasRotationAxis = true;
        this.valRotationAxis = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setScaleX(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B scaleX(double value)
    {
        this.hasScaleX = true;
        this.valScaleX = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setScaleY(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B scaleY(double value)
    {
        this.hasScaleY = true;
        this.valScaleY = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setScaleZ(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B scaleZ(double value)
    {
        this.hasScaleZ = true;
        this.valScaleZ = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setStyle(java.lang.String)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B style(java.lang.String value)
    {
        this.hasStyle = true;
        this.valStyle = value;
        return (B) this;
    }

    /**
     * 設定集合屬性{@link Node#getStyleClass}的內容
     *
     * @param value 新的集合內容
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B styleClass(java.util.Collection<java.lang.String> value)
    {
        this.hasStyleClass = true;
        this.valStyleClass = value;
        return (B) this;
    }

    /**
     * 設定集合屬性{@link Node#getStyleClass}的內容
     *
     * @param value 新的集合內容
     * @return 目前的建構器(this)
     */
    @SafeVarargs
    @SuppressWarnings("unchecked")
    public final B styleClass(java.lang.String... value)
    {
        this.hasStyleClass = true;
        this.valStyleClass = java.util.Arrays.asList(value);
        return (B) this;
    }

    /**
     * 設定集合屬性{@link Node#getTransforms}的內容
     *
     * @param value 新的集合內容
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B transforms(java.util.Collection<javafx.scene.transform.Transform> value)
    {
        this.hasTransforms = true;
        this.valTransforms = value;
        return (B) this;
    }

    /**
     * 設定集合屬性{@link Node#getTransforms}的內容
     *
     * @param value 新的集合內容
     * @return 目前的建構器(this)
     */
    @SafeVarargs
    @SuppressWarnings("unchecked")
    public final B transforms(javafx.scene.transform.Transform... value)
    {
        this.hasTransforms = true;
        this.valTransforms = java.util.Arrays.asList(value);
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setTranslateX(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B translateX(double value)
    {
        this.hasTranslateX = true;
        this.valTranslateX = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setTranslateY(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B translateY(double value)
    {
        this.hasTranslateY = true;
        this.valTranslateY = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setTranslateZ(double)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B translateZ(double value)
    {
        this.hasTranslateZ = true;
        this.valTranslateZ = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setUserData(java.lang.Object)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B userData(java.lang.Object value)
    {
        this.hasUserData = true;
        this.valUserData = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#setVisible(boolean)}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B visible(boolean value)
    {
        this.hasVisible = true;
        this.valVisible = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.AnchorPane#setBottomAnchor}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B AnchorPane_bottomAnchor(java.lang.Double value)
    {
        this.hasAnchorPane_bottomAnchor = true;
        this.valAnchorPane_bottomAnchor = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.AnchorPane#setLeftAnchor}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B AnchorPane_leftAnchor(java.lang.Double value)
    {
        this.hasAnchorPane_leftAnchor = true;
        this.valAnchorPane_leftAnchor = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.AnchorPane#setRightAnchor}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B AnchorPane_rightAnchor(java.lang.Double value)
    {
        this.hasAnchorPane_rightAnchor = true;
        this.valAnchorPane_rightAnchor = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.AnchorPane#setTopAnchor}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B AnchorPane_topAnchor(java.lang.Double value)
    {
        this.hasAnchorPane_topAnchor = true;
        this.valAnchorPane_topAnchor = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.BorderPane#setAlignment}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B BorderPane_alignment(javafx.geometry.Pos value)
    {
        this.hasBorderPane_alignment = true;
        this.valBorderPane_alignment = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.BorderPane#setMargin}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B BorderPane_margin(javafx.geometry.Insets value)
    {
        this.hasBorderPane_margin = true;
        this.valBorderPane_margin = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.FlowPane#setMargin}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B FlowPane_margin(javafx.geometry.Insets value)
    {
        this.hasFlowPane_margin = true;
        this.valFlowPane_margin = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setColumnIndex}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_columnIndex(java.lang.Integer value)
    {
        this.hasGridPane_columnIndex = true;
        this.valGridPane_columnIndex = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setColumnSpan}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_columnSpan(java.lang.Integer value)
    {
        this.hasGridPane_columnSpan = true;
        this.valGridPane_columnSpan = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setFillHeight}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_fillHeight(java.lang.Boolean value)
    {
        this.hasGridPane_fillHeight = true;
        this.valGridPane_fillHeight = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setFillWidth}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_fillWidth(java.lang.Boolean value)
    {
        this.hasGridPane_fillWidth = true;
        this.valGridPane_fillWidth = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setHalignment}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_halignment(javafx.geometry.HPos value)
    {
        this.hasGridPane_halignment = true;
        this.valGridPane_halignment = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setHgrow}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_hgrow(javafx.scene.layout.Priority value)
    {
        this.hasGridPane_hgrow = true;
        this.valGridPane_hgrow = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setMargin}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_margin(javafx.geometry.Insets value)
    {
        this.hasGridPane_margin = true;
        this.valGridPane_margin = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setRowIndex}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_rowIndex(java.lang.Integer value)
    {
        this.hasGridPane_rowIndex = true;
        this.valGridPane_rowIndex = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setRowSpan}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_rowSpan(java.lang.Integer value)
    {
        this.hasGridPane_rowSpan = true;
        this.valGridPane_rowSpan = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setValignment}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_valignment(javafx.geometry.VPos value)
    {
        this.hasGridPane_valignment = true;
        this.valGridPane_valignment = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.GridPane#setVgrow}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B GridPane_vgrow(javafx.scene.layout.Priority value)
    {
        this.hasGridPane_vgrow = true;
        this.valGridPane_vgrow = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.HBox#setHgrow}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B HBox_hgrow(javafx.scene.layout.Priority value)
    {
        this.hasHBox_hgrow = true;
        this.valHBox_hgrow = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.HBox#setMargin}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B HBox_margin(javafx.geometry.Insets value)
    {
        this.hasHBox_margin = true;
        this.valHBox_margin = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.control.SplitPane#setResizableWithParent}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B SplitPane_resizableWithParent(java.lang.Boolean value)
    {
        this.hasSplitPane_resizableWithParent = true;
        this.valSplitPane_resizableWithParent = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.StackPane#setAlignment}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B StackPane_alignment(javafx.geometry.Pos value)
    {
        this.hasStackPane_alignment = true;
        this.valStackPane_alignment = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.StackPane#setMargin}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B StackPane_margin(javafx.geometry.Insets value)
    {
        this.hasStackPane_margin = true;
        this.valStackPane_margin = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.TilePane#setAlignment}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B TilePane_alignment(javafx.geometry.Pos value)
    {
        this.hasTilePane_alignment = true;
        this.valTilePane_alignment = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.TilePane#setMargin}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B TilePane_margin(javafx.geometry.Insets value)
    {
        this.hasTilePane_margin = true;
        this.valTilePane_margin = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.VBox#setMargin}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B VBox_margin(javafx.geometry.Insets value)
    {
        this.hasVBox_margin = true;
        this.valVBox_margin = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link javafx.scene.layout.VBox#setVgrow}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B VBox_vgrow(javafx.scene.layout.Priority value)
    {
        this.hasVBox_vgrow = true;
        this.valVBox_vgrow = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#blendModeProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindBlendMode(javafx.beans.value.ObservableValue<? extends javafx.scene.effect.BlendMode> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundBlendMode = true;
        this.obsrvBlendMode = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#cacheHintProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindCacheHint(javafx.beans.value.ObservableValue<? extends javafx.scene.CacheHint> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundCacheHint = true;
        this.obsrvCacheHint = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#cacheProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindCache(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundCache = true;
        this.obsrvCache = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#clipProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindClip(javafx.beans.value.ObservableValue<? extends javafx.scene.Node> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundClip = true;
        this.obsrvClip = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#cursorProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindCursor(javafx.beans.value.ObservableValue<? extends javafx.scene.Cursor> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundCursor = true;
        this.obsrvCursor = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#depthTestProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindDepthTest(javafx.beans.value.ObservableValue<? extends javafx.scene.DepthTest> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundDepthTest = true;
        this.obsrvDepthTest = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#disableProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindDisable(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundDisable = true;
        this.obsrvDisable = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#effectProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindEffect(javafx.beans.value.ObservableValue<? extends javafx.scene.effect.Effect> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundEffect = true;
        this.obsrvEffect = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#eventDispatcherProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindEventDispatcher(javafx.beans.value.ObservableValue<? extends javafx.event.EventDispatcher> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundEventDispatcher = true;
        this.obsrvEventDispatcher = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#focusTraversableProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindFocusTraversable(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundFocusTraversable = true;
        this.obsrvFocusTraversable = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#idProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindId(javafx.beans.value.ObservableValue<? extends String> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundId = true;
        this.obsrvId = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#inputMethodRequestsProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindInputMethodRequests(javafx.beans.value.ObservableValue<? extends javafx.scene.input.InputMethodRequests> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundInputMethodRequests = true;
        this.obsrvInputMethodRequests = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#layoutXProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindLayoutX(javafx.beans.value.ObservableValue<? extends Double> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundLayoutX = true;
        this.obsrvLayoutX = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#layoutYProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindLayoutY(javafx.beans.value.ObservableValue<? extends Double> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundLayoutY = true;
        this.obsrvLayoutY = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#managedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindManaged(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundManaged = true;
        this.obsrvManaged = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#mouseTransparentProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindMouseTransparent(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundMouseTransparent = true;
        this.obsrvMouseTransparent = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#nodeOrientationProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindNodeOrientation(javafx.beans.value.ObservableValue<? extends javafx.geometry.NodeOrientation> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundNodeOrientation = true;
        this.obsrvNodeOrientation = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onContextMenuRequestedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnContextMenuRequested(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ContextMenuEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnContextMenuRequested = true;
        this.obsrvOnContextMenuRequested = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onDragDetectedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnDragDetected(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnDragDetected = true;
        this.obsrvOnDragDetected = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onDragDoneProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnDragDone(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnDragDone = true;
        this.obsrvOnDragDone = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onDragDroppedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnDragDropped(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnDragDropped = true;
        this.obsrvOnDragDropped = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onDragEnteredProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnDragEntered(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnDragEntered = true;
        this.obsrvOnDragEntered = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onDragExitedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnDragExited(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnDragExited = true;
        this.obsrvOnDragExited = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onDragOverProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnDragOver(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.DragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnDragOver = true;
        this.obsrvOnDragOver = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onInputMethodTextChangedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnInputMethodTextChanged(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.InputMethodEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnInputMethodTextChanged = true;
        this.obsrvOnInputMethodTextChanged = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onKeyPressedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnKeyPressed(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.KeyEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnKeyPressed = true;
        this.obsrvOnKeyPressed = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onKeyReleasedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnKeyReleased(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.KeyEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnKeyReleased = true;
        this.obsrvOnKeyReleased = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onKeyTypedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnKeyTyped(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.KeyEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnKeyTyped = true;
        this.obsrvOnKeyTyped = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseClickedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseClicked(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnMouseClicked = true;
        this.obsrvOnMouseClicked = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseDragEnteredProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseDragEntered(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnMouseDragEntered = true;
        this.obsrvOnMouseDragEntered = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseDragExitedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseDragExited(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnMouseDragExited = true;
        this.obsrvOnMouseDragExited = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseDragOverProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseDragOver(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnMouseDragOver = true;
        this.obsrvOnMouseDragOver = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseDragReleasedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseDragReleased(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseDragEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnMouseDragReleased = true;
        this.obsrvOnMouseDragReleased = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseDraggedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseDragged(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnMouseDragged = true;
        this.obsrvOnMouseDragged = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseEnteredProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseEntered(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnMouseEntered = true;
        this.obsrvOnMouseEntered = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseExitedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseExited(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnMouseExited = true;
        this.obsrvOnMouseExited = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseMovedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseMoved(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnMouseMoved = true;
        this.obsrvOnMouseMoved = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMousePressedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMousePressed(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnMousePressed = true;
        this.obsrvOnMousePressed = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onMouseReleasedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnMouseReleased(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.MouseEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnMouseReleased = true;
        this.obsrvOnMouseReleased = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onRotateProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnRotate(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.RotateEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnRotate = true;
        this.obsrvOnRotate = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onRotationFinishedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnRotationFinished(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.RotateEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnRotationFinished = true;
        this.obsrvOnRotationFinished = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onRotationStartedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnRotationStarted(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.RotateEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnRotationStarted = true;
        this.obsrvOnRotationStarted = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onScrollFinishedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnScrollFinished(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnScrollFinished = true;
        this.obsrvOnScrollFinished = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onScrollProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnScroll(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnScroll = true;
        this.obsrvOnScroll = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onScrollStartedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnScrollStarted(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ScrollEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnScrollStarted = true;
        this.obsrvOnScrollStarted = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onSwipeDownProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnSwipeDown(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnSwipeDown = true;
        this.obsrvOnSwipeDown = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onSwipeLeftProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnSwipeLeft(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnSwipeLeft = true;
        this.obsrvOnSwipeLeft = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onSwipeRightProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnSwipeRight(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnSwipeRight = true;
        this.obsrvOnSwipeRight = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onSwipeUpProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnSwipeUp(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.SwipeEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnSwipeUp = true;
        this.obsrvOnSwipeUp = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onTouchMovedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnTouchMoved(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnTouchMoved = true;
        this.obsrvOnTouchMoved = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onTouchPressedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnTouchPressed(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnTouchPressed = true;
        this.obsrvOnTouchPressed = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onTouchReleasedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnTouchReleased(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnTouchReleased = true;
        this.obsrvOnTouchReleased = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onTouchStationaryProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnTouchStationary(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.TouchEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnTouchStationary = true;
        this.obsrvOnTouchStationary = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onZoomFinishedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnZoomFinished(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnZoomFinished = true;
        this.obsrvOnZoomFinished = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onZoomProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnZoom(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnZoom = true;
        this.obsrvOnZoom = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#onZoomStartedProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOnZoomStarted(javafx.beans.value.ObservableValue<? extends javafx.event.EventHandler<? super javafx.scene.input.ZoomEvent>> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOnZoomStarted = true;
        this.obsrvOnZoomStarted = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#opacityProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindOpacity(javafx.beans.value.ObservableValue<? extends Double> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundOpacity = true;
        this.obsrvOpacity = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#pickOnBoundsProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindPickOnBounds(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundPickOnBounds = true;
        this.obsrvPickOnBounds = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#rotateProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindRotate(javafx.beans.value.ObservableValue<? extends Double> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundRotate = true;
        this.obsrvRotate = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#rotationAxisProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindRotationAxis(javafx.beans.value.ObservableValue<? extends javafx.geometry.Point3D> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundRotationAxis = true;
        this.obsrvRotationAxis = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#scaleXProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindScaleX(javafx.beans.value.ObservableValue<? extends Double> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundScaleX = true;
        this.obsrvScaleX = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#scaleYProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindScaleY(javafx.beans.value.ObservableValue<? extends Double> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundScaleY = true;
        this.obsrvScaleY = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#scaleZProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindScaleZ(javafx.beans.value.ObservableValue<? extends Double> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundScaleZ = true;
        this.obsrvScaleZ = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#styleProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindStyle(javafx.beans.value.ObservableValue<? extends String> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundStyle = true;
        this.obsrvStyle = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#translateXProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindTranslateX(javafx.beans.value.ObservableValue<? extends Double> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundTranslateX = true;
        this.obsrvTranslateX = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#translateYProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindTranslateY(javafx.beans.value.ObservableValue<? extends Double> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundTranslateY = true;
        this.obsrvTranslateY = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#translateZProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindTranslateZ(javafx.beans.value.ObservableValue<? extends Double> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundTranslateZ = true;
        this.obsrvTranslateZ = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Node#visibleProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public final B bindVisible(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        java.util.Objects.requireNonNull(source);
        this.boundVisible = true;
        this.obsrvVisible = source;
        return (B) this;
    }
}
