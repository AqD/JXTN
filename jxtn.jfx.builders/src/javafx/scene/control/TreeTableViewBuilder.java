// @formatter:off
/*
 * Unlicensed, generated by javafx.ftl
 */

package javafx.scene.control;

/**
 * {@link TreeTableView}建構器
 *
 * @author JarReflectionDataLoader-1.0.0
 * @version jfxrt.jar
 */
@javax.annotation.Generated("Generated by javafx.ftl")
@SuppressWarnings("all")
public class TreeTableViewBuilder<S extends java.lang.Object, Z extends TreeTableView<S>, B extends TreeTableViewBuilder<S, Z, B>>
        extends javafx.scene.control.ControlBuilder<Z, B>
{
    private boolean applied;

    protected boolean hasColumnResizePolicy;
    protected javafx.util.Callback<javafx.scene.control.TreeTableView.ResizeFeatures, java.lang.Boolean> valColumnResizePolicy;

    protected boolean hasColumns;
    protected java.util.Collection<javafx.scene.control.TreeTableColumn<S, ?>> valColumns;

    protected boolean hasEditable;
    protected boolean valEditable;

    protected boolean hasFixedCellSize;
    protected double valFixedCellSize;

    protected boolean hasFocusModel;
    protected javafx.scene.control.TreeTableView.TreeTableViewFocusModel<S> valFocusModel;

    protected boolean hasOnScrollTo;
    protected javafx.event.EventHandler<javafx.scene.control.ScrollToEvent<java.lang.Integer>> valOnScrollTo;

    protected boolean hasOnScrollToColumn;
    protected javafx.event.EventHandler<javafx.scene.control.ScrollToEvent<javafx.scene.control.TreeTableColumn<S, ?>>> valOnScrollToColumn;

    protected boolean hasOnSort;
    protected javafx.event.EventHandler<javafx.scene.control.SortEvent<javafx.scene.control.TreeTableView<S>>> valOnSort;

    protected boolean hasPlaceholder;
    protected javafx.scene.Node valPlaceholder;

    protected boolean hasRoot;
    protected javafx.scene.control.TreeItem<S> valRoot;

    protected boolean hasRowFactory;
    protected javafx.util.Callback<javafx.scene.control.TreeTableView<S>, javafx.scene.control.TreeTableRow<S>> valRowFactory;

    protected boolean hasSelectionModel;
    protected javafx.scene.control.TreeTableView.TreeTableViewSelectionModel<S> valSelectionModel;

    protected boolean hasShowRoot;
    protected boolean valShowRoot;

    protected boolean hasSortMode;
    protected javafx.scene.control.TreeSortMode valSortMode;

    protected boolean hasSortOrder;
    protected java.util.Collection<javafx.scene.control.TreeTableColumn<S, ?>> valSortOrder;

    protected boolean hasSortPolicy;
    protected javafx.util.Callback<javafx.scene.control.TreeTableView<S>, java.lang.Boolean> valSortPolicy;

    protected boolean hasTableMenuButtonVisible;
    protected boolean valTableMenuButtonVisible;

    protected boolean hasTreeColumn;
    protected javafx.scene.control.TreeTableColumn<S, ?> valTreeColumn;

    protected boolean hasVisibleLeafColumns;
    protected java.util.Collection<javafx.scene.control.TreeTableColumn<S, ?>> valVisibleLeafColumns;

    protected boolean boundColumnResizePolicy;
    protected javafx.beans.value.ObservableValue<? extends javafx.util.Callback<javafx.scene.control.TreeTableView.ResizeFeatures, java.lang.Boolean>> obsrvColumnResizePolicy;

    protected boolean boundEditable;
    protected javafx.beans.value.ObservableValue<? extends Boolean> obsrvEditable;

    protected boolean boundFixedCellSize;
    protected javafx.beans.value.ObservableValue<? extends Double> obsrvFixedCellSize;

    protected boolean boundFocusModel;
    protected javafx.beans.value.ObservableValue<? extends javafx.scene.control.TreeTableView.TreeTableViewFocusModel<S>> obsrvFocusModel;

    protected boolean boundPlaceholder;
    protected javafx.beans.value.ObservableValue<? extends javafx.scene.Node> obsrvPlaceholder;

    protected boolean boundRoot;
    protected javafx.beans.value.ObservableValue<? extends javafx.scene.control.TreeItem<S>> obsrvRoot;

    protected boolean boundRowFactory;
    protected javafx.beans.value.ObservableValue<? extends javafx.util.Callback<javafx.scene.control.TreeTableView<S>, javafx.scene.control.TreeTableRow<S>>> obsrvRowFactory;

    protected boolean boundSelectionModel;
    protected javafx.beans.value.ObservableValue<? extends javafx.scene.control.TreeTableView.TreeTableViewSelectionModel<S>> obsrvSelectionModel;

    protected boolean boundShowRoot;
    protected javafx.beans.value.ObservableValue<? extends Boolean> obsrvShowRoot;

    protected boolean boundSortMode;
    protected javafx.beans.value.ObservableValue<? extends javafx.scene.control.TreeSortMode> obsrvSortMode;

    protected boolean boundSortPolicy;
    protected javafx.beans.value.ObservableValue<? extends javafx.util.Callback<javafx.scene.control.TreeTableView<S>, java.lang.Boolean>> obsrvSortPolicy;

    protected boolean boundTableMenuButtonVisible;
    protected javafx.beans.value.ObservableValue<? extends Boolean> obsrvTableMenuButtonVisible;

    protected boolean boundTreeColumn;
    protected javafx.beans.value.ObservableValue<? extends javafx.scene.control.TreeTableColumn<S, ?>> obsrvTreeColumn;
    public void applyTo(TreeTableView<S> instance)
    {
        super.applyTo(instance);
        if (this.applied)
            throw new IllegalStateException();
        if (this.hasColumnResizePolicy)
            instance.setColumnResizePolicy(this.valColumnResizePolicy);
        if (this.hasColumns)
            instance.getColumns().setAll(this.valColumns);
        if (this.hasEditable)
            instance.setEditable(this.valEditable);
        if (this.hasFixedCellSize)
            instance.setFixedCellSize(this.valFixedCellSize);
        if (this.hasFocusModel)
            instance.setFocusModel(this.valFocusModel);
        if (this.hasOnScrollTo)
            instance.setOnScrollTo(this.valOnScrollTo);
        if (this.hasOnScrollToColumn)
            instance.setOnScrollToColumn(this.valOnScrollToColumn);
        if (this.hasOnSort)
            instance.setOnSort(this.valOnSort);
        if (this.hasPlaceholder)
            instance.setPlaceholder(this.valPlaceholder);
        if (this.hasRoot)
            instance.setRoot(this.valRoot);
        if (this.hasRowFactory)
            instance.setRowFactory(this.valRowFactory);
        if (this.hasSelectionModel)
            instance.setSelectionModel(this.valSelectionModel);
        if (this.hasShowRoot)
            instance.setShowRoot(this.valShowRoot);
        if (this.hasSortMode)
            instance.setSortMode(this.valSortMode);
        if (this.hasSortOrder)
            instance.getSortOrder().setAll(this.valSortOrder);
        if (this.hasSortPolicy)
            instance.setSortPolicy(this.valSortPolicy);
        if (this.hasTableMenuButtonVisible)
            instance.setTableMenuButtonVisible(this.valTableMenuButtonVisible);
        if (this.hasTreeColumn)
            instance.setTreeColumn(this.valTreeColumn);
        if (this.hasVisibleLeafColumns)
            instance.getVisibleLeafColumns().setAll(this.valVisibleLeafColumns);
        if (this.boundColumnResizePolicy)
            instance.columnResizePolicyProperty().bind(this.obsrvColumnResizePolicy);
        if (this.boundEditable)
            instance.editableProperty().bind(this.obsrvEditable);
        if (this.boundFixedCellSize)
            instance.fixedCellSizeProperty().bind(this.obsrvFixedCellSize);
        if (this.boundFocusModel)
            instance.focusModelProperty().bind(this.obsrvFocusModel);
        if (this.boundPlaceholder)
            instance.placeholderProperty().bind(this.obsrvPlaceholder);
        if (this.boundRoot)
            instance.rootProperty().bind(this.obsrvRoot);
        if (this.boundRowFactory)
            instance.rowFactoryProperty().bind(this.obsrvRowFactory);
        if (this.boundSelectionModel)
            instance.selectionModelProperty().bind(this.obsrvSelectionModel);
        if (this.boundShowRoot)
            instance.showRootProperty().bind(this.obsrvShowRoot);
        if (this.boundSortMode)
            instance.sortModeProperty().bind(this.obsrvSortMode);
        if (this.boundSortPolicy)
            instance.sortPolicyProperty().bind(this.obsrvSortPolicy);
        if (this.boundTableMenuButtonVisible)
            instance.tableMenuButtonVisibleProperty().bind(this.obsrvTableMenuButtonVisible);
        if (this.boundTreeColumn)
            instance.treeColumnProperty().bind(this.obsrvTreeColumn);
        //
        this.applied = true;
    }

    @SuppressWarnings("unchecked")
    public B columnResizePolicy(javafx.util.Callback<javafx.scene.control.TreeTableView.ResizeFeatures, java.lang.Boolean> value)
    {
        this.hasColumnResizePolicy = true;
        this.valColumnResizePolicy = value;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B columns(java.util.Collection<javafx.scene.control.TreeTableColumn<S, ?>> value)
    {
        this.hasColumns = true;
        this.valColumns = value;
        return (B) this;
    }

    @SafeVarargs
    @SuppressWarnings("unchecked")
    public final B columns(javafx.scene.control.TreeTableColumn<S, ?>... value)
    {
        this.hasColumns = true;
        this.valColumns = java.util.Arrays.asList(value);
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B editable(boolean value)
    {
        this.hasEditable = true;
        this.valEditable = value;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B fixedCellSize(double value)
    {
        this.hasFixedCellSize = true;
        this.valFixedCellSize = value;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B focusModel(javafx.scene.control.TreeTableView.TreeTableViewFocusModel<S> value)
    {
        this.hasFocusModel = true;
        this.valFocusModel = value;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B onScrollTo(javafx.event.EventHandler<javafx.scene.control.ScrollToEvent<java.lang.Integer>> value)
    {
        this.hasOnScrollTo = true;
        this.valOnScrollTo = value;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B onScrollToColumn(javafx.event.EventHandler<javafx.scene.control.ScrollToEvent<javafx.scene.control.TreeTableColumn<S, ?>>> value)
    {
        this.hasOnScrollToColumn = true;
        this.valOnScrollToColumn = value;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B onSort(javafx.event.EventHandler<javafx.scene.control.SortEvent<javafx.scene.control.TreeTableView<S>>> value)
    {
        this.hasOnSort = true;
        this.valOnSort = value;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B placeholder(javafx.scene.Node value)
    {
        this.hasPlaceholder = true;
        this.valPlaceholder = value;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B root(javafx.scene.control.TreeItem<S> value)
    {
        this.hasRoot = true;
        this.valRoot = value;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B rowFactory(javafx.util.Callback<javafx.scene.control.TreeTableView<S>, javafx.scene.control.TreeTableRow<S>> value)
    {
        this.hasRowFactory = true;
        this.valRowFactory = value;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B selectionModel(javafx.scene.control.TreeTableView.TreeTableViewSelectionModel<S> value)
    {
        this.hasSelectionModel = true;
        this.valSelectionModel = value;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B showRoot(boolean value)
    {
        this.hasShowRoot = true;
        this.valShowRoot = value;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B sortMode(javafx.scene.control.TreeSortMode value)
    {
        this.hasSortMode = true;
        this.valSortMode = value;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B sortOrder(java.util.Collection<javafx.scene.control.TreeTableColumn<S, ?>> value)
    {
        this.hasSortOrder = true;
        this.valSortOrder = value;
        return (B) this;
    }

    @SafeVarargs
    @SuppressWarnings("unchecked")
    public final B sortOrder(javafx.scene.control.TreeTableColumn<S, ?>... value)
    {
        this.hasSortOrder = true;
        this.valSortOrder = java.util.Arrays.asList(value);
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B sortPolicy(javafx.util.Callback<javafx.scene.control.TreeTableView<S>, java.lang.Boolean> value)
    {
        this.hasSortPolicy = true;
        this.valSortPolicy = value;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B tableMenuButtonVisible(boolean value)
    {
        this.hasTableMenuButtonVisible = true;
        this.valTableMenuButtonVisible = value;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B treeColumn(javafx.scene.control.TreeTableColumn<S, ?> value)
    {
        this.hasTreeColumn = true;
        this.valTreeColumn = value;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B visibleLeafColumns(java.util.Collection<javafx.scene.control.TreeTableColumn<S, ?>> value)
    {
        this.hasVisibleLeafColumns = true;
        this.valVisibleLeafColumns = value;
        return (B) this;
    }

    @SafeVarargs
    @SuppressWarnings("unchecked")
    public final B visibleLeafColumns(javafx.scene.control.TreeTableColumn<S, ?>... value)
    {
        this.hasVisibleLeafColumns = true;
        this.valVisibleLeafColumns = java.util.Arrays.asList(value);
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B bindColumnResizePolicy(javafx.beans.value.ObservableValue<? extends javafx.util.Callback<javafx.scene.control.TreeTableView.ResizeFeatures, java.lang.Boolean>> source)
    {
        assert (source != null);
        this.boundColumnResizePolicy = true;
        this.obsrvColumnResizePolicy = source;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B bindEditable(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        assert (source != null);
        this.boundEditable = true;
        this.obsrvEditable = source;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B bindFixedCellSize(javafx.beans.value.ObservableValue<? extends Double> source)
    {
        assert (source != null);
        this.boundFixedCellSize = true;
        this.obsrvFixedCellSize = source;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B bindFocusModel(javafx.beans.value.ObservableValue<? extends javafx.scene.control.TreeTableView.TreeTableViewFocusModel<S>> source)
    {
        assert (source != null);
        this.boundFocusModel = true;
        this.obsrvFocusModel = source;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B bindPlaceholder(javafx.beans.value.ObservableValue<? extends javafx.scene.Node> source)
    {
        assert (source != null);
        this.boundPlaceholder = true;
        this.obsrvPlaceholder = source;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B bindRoot(javafx.beans.value.ObservableValue<? extends javafx.scene.control.TreeItem<S>> source)
    {
        assert (source != null);
        this.boundRoot = true;
        this.obsrvRoot = source;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B bindRowFactory(javafx.beans.value.ObservableValue<? extends javafx.util.Callback<javafx.scene.control.TreeTableView<S>, javafx.scene.control.TreeTableRow<S>>> source)
    {
        assert (source != null);
        this.boundRowFactory = true;
        this.obsrvRowFactory = source;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B bindSelectionModel(javafx.beans.value.ObservableValue<? extends javafx.scene.control.TreeTableView.TreeTableViewSelectionModel<S>> source)
    {
        assert (source != null);
        this.boundSelectionModel = true;
        this.obsrvSelectionModel = source;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B bindShowRoot(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        assert (source != null);
        this.boundShowRoot = true;
        this.obsrvShowRoot = source;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B bindSortMode(javafx.beans.value.ObservableValue<? extends javafx.scene.control.TreeSortMode> source)
    {
        assert (source != null);
        this.boundSortMode = true;
        this.obsrvSortMode = source;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B bindSortPolicy(javafx.beans.value.ObservableValue<? extends javafx.util.Callback<javafx.scene.control.TreeTableView<S>, java.lang.Boolean>> source)
    {
        assert (source != null);
        this.boundSortPolicy = true;
        this.obsrvSortPolicy = source;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B bindTableMenuButtonVisible(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        assert (source != null);
        this.boundTableMenuButtonVisible = true;
        this.obsrvTableMenuButtonVisible = source;
        return (B) this;
    }

    @SuppressWarnings("unchecked")
    public B bindTreeColumn(javafx.beans.value.ObservableValue<? extends javafx.scene.control.TreeTableColumn<S, ?>> source)
    {
        assert (source != null);
        this.boundTreeColumn = true;
        this.obsrvTreeColumn = source;
        return (B) this;
    }

    @Override
    @SuppressWarnings("unchecked")
    public TreeTableView<S> build()
    {
        TreeTableView<S> instance = new TreeTableView<S>();
        this.applyTo(instance);
        this.doAfterBuild((Z) instance);
        return instance;
    }
}
