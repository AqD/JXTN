// @formatter:off
/*
 * Unlicensed, generated by javafx.ftl
 */

package javafx.scene.control;

/**
 * {@link Labeled}建構器
 *
 * @author JarReflectionDataLoader-1.0.0
 * @version jfxrt.jar
 */
@javax.annotation.Generated("Generated by javafx.ftl")
@SuppressWarnings("all")
public class LabeledBuilder<Z extends Labeled, B extends LabeledBuilder<Z, B>>
        extends javafx.scene.control.ControlBuilder<Z, B>
{

    protected boolean hasAlignment;
    protected javafx.geometry.Pos valAlignment;

    protected boolean hasContentDisplay;
    protected javafx.scene.control.ContentDisplay valContentDisplay;

    protected boolean hasEllipsisString;
    protected java.lang.String valEllipsisString;

    protected boolean hasFont;
    protected javafx.scene.text.Font valFont;

    protected boolean hasGraphic;
    protected javafx.scene.Node valGraphic;

    protected boolean hasGraphicTextGap;
    protected double valGraphicTextGap;

    protected boolean hasLineSpacing;
    protected double valLineSpacing;

    protected boolean hasMnemonicParsing;
    protected boolean valMnemonicParsing;

    protected boolean hasText;
    protected java.lang.String valText;

    protected boolean hasTextAlignment;
    protected javafx.scene.text.TextAlignment valTextAlignment;

    protected boolean hasTextFill;
    protected javafx.scene.paint.Paint valTextFill;

    protected boolean hasTextOverrun;
    protected javafx.scene.control.OverrunStyle valTextOverrun;

    protected boolean hasUnderline;
    protected boolean valUnderline;

    protected boolean hasWrapText;
    protected boolean valWrapText;

    protected boolean boundAlignment;
    protected javafx.beans.value.ObservableValue<? extends javafx.geometry.Pos> obsrvAlignment;

    protected boolean boundContentDisplay;
    protected javafx.beans.value.ObservableValue<? extends javafx.scene.control.ContentDisplay> obsrvContentDisplay;

    protected boolean boundEllipsisString;
    protected javafx.beans.value.ObservableValue<? extends String> obsrvEllipsisString;

    protected boolean boundFont;
    protected javafx.beans.value.ObservableValue<? extends javafx.scene.text.Font> obsrvFont;

    protected boolean boundGraphic;
    protected javafx.beans.value.ObservableValue<? extends javafx.scene.Node> obsrvGraphic;

    protected boolean boundGraphicTextGap;
    protected javafx.beans.value.ObservableValue<? extends Double> obsrvGraphicTextGap;

    protected boolean boundLineSpacing;
    protected javafx.beans.value.ObservableValue<? extends Double> obsrvLineSpacing;

    protected boolean boundMnemonicParsing;
    protected javafx.beans.value.ObservableValue<? extends Boolean> obsrvMnemonicParsing;

    protected boolean boundTextAlignment;
    protected javafx.beans.value.ObservableValue<? extends javafx.scene.text.TextAlignment> obsrvTextAlignment;

    protected boolean boundTextFill;
    protected javafx.beans.value.ObservableValue<? extends javafx.scene.paint.Paint> obsrvTextFill;

    protected boolean boundTextOverrun;
    protected javafx.beans.value.ObservableValue<? extends javafx.scene.control.OverrunStyle> obsrvTextOverrun;

    protected boolean boundText;
    protected javafx.beans.value.ObservableValue<? extends String> obsrvText;

    protected boolean boundUnderline;
    protected javafx.beans.value.ObservableValue<? extends Boolean> obsrvUnderline;

    protected boolean boundWrapText;
    protected javafx.beans.value.ObservableValue<? extends Boolean> obsrvWrapText;

    @Override
    public void applyTo(Z instance)
    {
        super.applyTo(instance);
        if (this.hasAlignment)
            instance.setAlignment(this.valAlignment);
        if (this.hasContentDisplay)
            instance.setContentDisplay(this.valContentDisplay);
        if (this.hasEllipsisString)
            instance.setEllipsisString(this.valEllipsisString);
        if (this.hasFont)
            instance.setFont(this.valFont);
        if (this.hasGraphic)
            instance.setGraphic(this.valGraphic);
        if (this.hasGraphicTextGap)
            instance.setGraphicTextGap(this.valGraphicTextGap);
        if (this.hasLineSpacing)
            instance.setLineSpacing(this.valLineSpacing);
        if (this.hasMnemonicParsing)
            instance.setMnemonicParsing(this.valMnemonicParsing);
        if (this.hasText)
            instance.setText(this.valText);
        if (this.hasTextAlignment)
            instance.setTextAlignment(this.valTextAlignment);
        if (this.hasTextFill)
            instance.setTextFill(this.valTextFill);
        if (this.hasTextOverrun)
            instance.setTextOverrun(this.valTextOverrun);
        if (this.hasUnderline)
            instance.setUnderline(this.valUnderline);
        if (this.hasWrapText)
            instance.setWrapText(this.valWrapText);
        if (this.boundAlignment)
            instance.alignmentProperty().bind(this.obsrvAlignment);
        if (this.boundContentDisplay)
            instance.contentDisplayProperty().bind(this.obsrvContentDisplay);
        if (this.boundEllipsisString)
            instance.ellipsisStringProperty().bind(this.obsrvEllipsisString);
        if (this.boundFont)
            instance.fontProperty().bind(this.obsrvFont);
        if (this.boundGraphic)
            instance.graphicProperty().bind(this.obsrvGraphic);
        if (this.boundGraphicTextGap)
            instance.graphicTextGapProperty().bind(this.obsrvGraphicTextGap);
        if (this.boundLineSpacing)
            instance.lineSpacingProperty().bind(this.obsrvLineSpacing);
        if (this.boundMnemonicParsing)
            instance.mnemonicParsingProperty().bind(this.obsrvMnemonicParsing);
        if (this.boundTextAlignment)
            instance.textAlignmentProperty().bind(this.obsrvTextAlignment);
        if (this.boundTextFill)
            instance.textFillProperty().bind(this.obsrvTextFill);
        if (this.boundTextOverrun)
            instance.textOverrunProperty().bind(this.obsrvTextOverrun);
        if (this.boundText)
            instance.textProperty().bind(this.obsrvText);
        if (this.boundUnderline)
            instance.underlineProperty().bind(this.obsrvUnderline);
        if (this.boundWrapText)
            instance.wrapTextProperty().bind(this.obsrvWrapText);
    }

    /**
     * 設定屬性{@link Labeled#setAlignment}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B alignment(javafx.geometry.Pos value)
    {
        this.hasAlignment = true;
        this.valAlignment = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#setContentDisplay}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B contentDisplay(javafx.scene.control.ContentDisplay value)
    {
        this.hasContentDisplay = true;
        this.valContentDisplay = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#setEllipsisString}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B ellipsisString(java.lang.String value)
    {
        this.hasEllipsisString = true;
        this.valEllipsisString = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#setFont}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B font(javafx.scene.text.Font value)
    {
        this.hasFont = true;
        this.valFont = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#setGraphic}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B graphic(javafx.scene.Node value)
    {
        this.hasGraphic = true;
        this.valGraphic = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#setGraphicTextGap}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B graphicTextGap(double value)
    {
        this.hasGraphicTextGap = true;
        this.valGraphicTextGap = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#setLineSpacing}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B lineSpacing(double value)
    {
        this.hasLineSpacing = true;
        this.valLineSpacing = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#setMnemonicParsing}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B mnemonicParsing(boolean value)
    {
        this.hasMnemonicParsing = true;
        this.valMnemonicParsing = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#setText}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B text(java.lang.String value)
    {
        this.hasText = true;
        this.valText = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#setTextAlignment}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B textAlignment(javafx.scene.text.TextAlignment value)
    {
        this.hasTextAlignment = true;
        this.valTextAlignment = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#setTextFill}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B textFill(javafx.scene.paint.Paint value)
    {
        this.hasTextFill = true;
        this.valTextFill = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#setTextOverrun}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B textOverrun(javafx.scene.control.OverrunStyle value)
    {
        this.hasTextOverrun = true;
        this.valTextOverrun = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#setUnderline}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B underline(boolean value)
    {
        this.hasUnderline = true;
        this.valUnderline = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#setWrapText}
     *
     * @param value 新的屬性值
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B wrapText(boolean value)
    {
        this.hasWrapText = true;
        this.valWrapText = value;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#alignmentProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B bindAlignment(javafx.beans.value.ObservableValue<? extends javafx.geometry.Pos> source)
    {
        assert (source != null);
        this.boundAlignment = true;
        this.obsrvAlignment = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#contentDisplayProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B bindContentDisplay(javafx.beans.value.ObservableValue<? extends javafx.scene.control.ContentDisplay> source)
    {
        assert (source != null);
        this.boundContentDisplay = true;
        this.obsrvContentDisplay = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#ellipsisStringProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B bindEllipsisString(javafx.beans.value.ObservableValue<? extends String> source)
    {
        assert (source != null);
        this.boundEllipsisString = true;
        this.obsrvEllipsisString = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#fontProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B bindFont(javafx.beans.value.ObservableValue<? extends javafx.scene.text.Font> source)
    {
        assert (source != null);
        this.boundFont = true;
        this.obsrvFont = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#graphicProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B bindGraphic(javafx.beans.value.ObservableValue<? extends javafx.scene.Node> source)
    {
        assert (source != null);
        this.boundGraphic = true;
        this.obsrvGraphic = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#graphicTextGapProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B bindGraphicTextGap(javafx.beans.value.ObservableValue<? extends Double> source)
    {
        assert (source != null);
        this.boundGraphicTextGap = true;
        this.obsrvGraphicTextGap = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#lineSpacingProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B bindLineSpacing(javafx.beans.value.ObservableValue<? extends Double> source)
    {
        assert (source != null);
        this.boundLineSpacing = true;
        this.obsrvLineSpacing = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#mnemonicParsingProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B bindMnemonicParsing(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        assert (source != null);
        this.boundMnemonicParsing = true;
        this.obsrvMnemonicParsing = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#textAlignmentProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B bindTextAlignment(javafx.beans.value.ObservableValue<? extends javafx.scene.text.TextAlignment> source)
    {
        assert (source != null);
        this.boundTextAlignment = true;
        this.obsrvTextAlignment = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#textFillProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B bindTextFill(javafx.beans.value.ObservableValue<? extends javafx.scene.paint.Paint> source)
    {
        assert (source != null);
        this.boundTextFill = true;
        this.obsrvTextFill = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#textOverrunProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B bindTextOverrun(javafx.beans.value.ObservableValue<? extends javafx.scene.control.OverrunStyle> source)
    {
        assert (source != null);
        this.boundTextOverrun = true;
        this.obsrvTextOverrun = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#textProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B bindText(javafx.beans.value.ObservableValue<? extends String> source)
    {
        assert (source != null);
        this.boundText = true;
        this.obsrvText = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#underlineProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B bindUnderline(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        assert (source != null);
        this.boundUnderline = true;
        this.obsrvUnderline = source;
        return (B) this;
    }

    /**
     * 設定屬性{@link Labeled#wrapTextProperty}的連結
     *
     * @param value 新的屬性連結(單向)
     * @return 目前的建構器(this)
     */
    @SuppressWarnings("unchecked")
    public B bindWrapText(javafx.beans.value.ObservableValue<? extends Boolean> source)
    {
        assert (source != null);
        this.boundWrapText = true;
        this.obsrvWrapText = source;
        return (B) this;
    }
}
